<!DOCTYPE html>
<html lang="ko" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content=" 10주차 학습 정리 - 1 이번 주 키워드 Spring DI &amp; AOP Spring MVC 동작 원리 DAO, DTO, Service 계층 분리 MyBatis SQL 매핑 트랜잭션(Transaction) 처리 1. Spring의 핵심 철학: DI와 AOP 의존성 주입 (DI, Dependency Injection) IoC (제어의 역전): 객체의 생성과 생명주기를 개발자가 아닌 스프링 컨테이너(ApplicationContext)가 관리하는 개념 Bean (빈): 스프링 컨테이너가 관리하는 자바 객체(POJO) DI (의존성 주입): 필요한 객체를 직접 생성하지 않고 외부(스프링 컨테이너)에서 주입받는 방식 @Autowired: 타입을 기준으로 빈을 찾아 자동으로 의존성을 주입 @Resource: 이름을 기준으로 빈을 찾아 자동으로 의존성을 주입 @Component: 클래스를 스캔하여 빈으로 자동 등록 관점 지향 프로그래밍 (AOP, Aspect Oriented Programming) AOP: 트랜잭션, 로깅, 보안 등 여러 메서드에 공통적으로 필요한 **부가 기능(횡단 관심사)**을 핵심 비즈니스 로직에서 분리하는 기술 주요 용어: Advice: 부가 기능 자체(코드). Join point: Advice가 적용될 수 있는 위치 (예: 메서드) Pointcut: Advice를 실제로 적용할 Join point를 선별하는 패턴 Weaving: Advice를 핵심 로직에 적용하여 프록시(Proxy) 객체를 만드는 과정 2. Spring MVC 아키텍처 심화 DispatcherServlet: 모든 클라이언트의 요청을 가장 먼저 받아 처리 흐름을 제어하는 중앙 컨트롤러 요청 처리 흐름: 요청 → DispatcherServlet HandlerMapping이 요청 URL에 맞는 Controller 탐색. HandlerAdapter가 Controller의 메서드를 호출 Controller는 비즈니스 로직 처리 후, View 이름과 Model을 반환 ViewResolver가 View 이름을 기반으로 실제 View(JSP 등)를 찾아 렌더링 상태 관리: 쿠키 vs 세션 쿠키(Cookie): 사용자의 정보를 **브라우저(클라이언트)**에 저장하는 작은 데이터 조각 세션(Session): 사용자의 정보를 서버에 저장하고, JSESSIONID 쿠키를 통해 클라이언트를 식별하는 방식 예외 처리 @ExceptionHandler: 컨트롤러 내에서 특정 예외를 처리하는 메서드를 지정 @ControllerAdvice: 여러 컨트롤러에 걸쳐 발생하는 예외를 전역적으로 처리 3. 데이터베이스 연동과 계층형 아키텍처 계층 분리(Layering): 유지보수성과 재사용성을 높이기 위해 코드를 Controller - Service - Repository(DAO) 계층으로 분리 Controller: HTTP 요청/응답 처리 Service: 비즈니스 로직 및 트랜잭션 처리 Repository(DAO): 순수 데이터베이스 접근(CRUD) 담당 DTO (Data Transfer Object): 계층 간 데이터 전송을 위해 사용되는 객체 MyBatis 연동 MyBatis: SQL 쿼리를 Java 코드에서 분리하여 XML 파일(Mapper)로 관리하는 SQL 매핑 프레임워크 SqlSession: SQL 실행에 필요한 메서드(insert, selectOne 등)를 제공하는 핵심 객체 동적 쿼리: &lt;if&gt;, &lt;choose&gt;, &lt;foreach&gt; 등의 태그를 사용해 조건에 따라 SQL을 동적으로 생성 가능. 검색 기능 구현 시 매우 유용 4. 트랜잭션 관리와 REST API 트랜잭션 (Transaction) 정의: &lsquo;모 아니면 도&rsquo;처럼, 모두 성공하거나 모두 실패해야 하는 분리될 수 없는 하나의 작업 단위 ACID 속성: 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 영속성(Durability)을 보장 Spring의 트랜잭션 처리: @Transactional 어노테이션을 서비스 계층 메서드에 추가하면, AOP를 통해 트랜잭션의 시작, 커밋, 롤백이 자동으로 관리됨 REST API와 Ajax REST API: 자원(Resource)을 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)로 해당 자원에 대한 행위를 정의하는 아키텍처 스타일 Ajax: 웹 페이지 전체를 새로고침하지 않고, 백그라운드에서 서버와 데이터를 교환하여 화면 일부만 동적으로 갱신하는 기술 @RestController: @Controller와 @ResponseBody를 합친 것으로, 메서드의 반환 값을 View가 아닌 JSON 등의 데이터 형식으로 반환할 때 사용 마무리 스프링 프레임워크를 적용하게 되면 단순히 코드를 분리하는 것을 넘어, 각 계층의 책임이 명확해지고,\n@Transactional 어노테이션 하나로 서비스 계층의 비즈니스 로직 전체를 원자적 단위로 묶어 처리할 수 있다는 점이\n인상 깊었다.\n">
<title>[커널아카데미] 백엔드 개발 부트캠프 13기 10주차(1)</title>

<link rel='canonical' href='http://localhost:1313/posts/week10-1-retrospective/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="[커널아카데미] 백엔드 개발 부트캠프 13기 10주차(1)">
<meta property='og:description' content=" 10주차 학습 정리 - 1 이번 주 키워드 Spring DI &amp; AOP Spring MVC 동작 원리 DAO, DTO, Service 계층 분리 MyBatis SQL 매핑 트랜잭션(Transaction) 처리 1. Spring의 핵심 철학: DI와 AOP 의존성 주입 (DI, Dependency Injection) IoC (제어의 역전): 객체의 생성과 생명주기를 개발자가 아닌 스프링 컨테이너(ApplicationContext)가 관리하는 개념 Bean (빈): 스프링 컨테이너가 관리하는 자바 객체(POJO) DI (의존성 주입): 필요한 객체를 직접 생성하지 않고 외부(스프링 컨테이너)에서 주입받는 방식 @Autowired: 타입을 기준으로 빈을 찾아 자동으로 의존성을 주입 @Resource: 이름을 기준으로 빈을 찾아 자동으로 의존성을 주입 @Component: 클래스를 스캔하여 빈으로 자동 등록 관점 지향 프로그래밍 (AOP, Aspect Oriented Programming) AOP: 트랜잭션, 로깅, 보안 등 여러 메서드에 공통적으로 필요한 **부가 기능(횡단 관심사)**을 핵심 비즈니스 로직에서 분리하는 기술 주요 용어: Advice: 부가 기능 자체(코드). Join point: Advice가 적용될 수 있는 위치 (예: 메서드) Pointcut: Advice를 실제로 적용할 Join point를 선별하는 패턴 Weaving: Advice를 핵심 로직에 적용하여 프록시(Proxy) 객체를 만드는 과정 2. Spring MVC 아키텍처 심화 DispatcherServlet: 모든 클라이언트의 요청을 가장 먼저 받아 처리 흐름을 제어하는 중앙 컨트롤러 요청 처리 흐름: 요청 → DispatcherServlet HandlerMapping이 요청 URL에 맞는 Controller 탐색. HandlerAdapter가 Controller의 메서드를 호출 Controller는 비즈니스 로직 처리 후, View 이름과 Model을 반환 ViewResolver가 View 이름을 기반으로 실제 View(JSP 등)를 찾아 렌더링 상태 관리: 쿠키 vs 세션 쿠키(Cookie): 사용자의 정보를 **브라우저(클라이언트)**에 저장하는 작은 데이터 조각 세션(Session): 사용자의 정보를 서버에 저장하고, JSESSIONID 쿠키를 통해 클라이언트를 식별하는 방식 예외 처리 @ExceptionHandler: 컨트롤러 내에서 특정 예외를 처리하는 메서드를 지정 @ControllerAdvice: 여러 컨트롤러에 걸쳐 발생하는 예외를 전역적으로 처리 3. 데이터베이스 연동과 계층형 아키텍처 계층 분리(Layering): 유지보수성과 재사용성을 높이기 위해 코드를 Controller - Service - Repository(DAO) 계층으로 분리 Controller: HTTP 요청/응답 처리 Service: 비즈니스 로직 및 트랜잭션 처리 Repository(DAO): 순수 데이터베이스 접근(CRUD) 담당 DTO (Data Transfer Object): 계층 간 데이터 전송을 위해 사용되는 객체 MyBatis 연동 MyBatis: SQL 쿼리를 Java 코드에서 분리하여 XML 파일(Mapper)로 관리하는 SQL 매핑 프레임워크 SqlSession: SQL 실행에 필요한 메서드(insert, selectOne 등)를 제공하는 핵심 객체 동적 쿼리: &lt;if&gt;, &lt;choose&gt;, &lt;foreach&gt; 등의 태그를 사용해 조건에 따라 SQL을 동적으로 생성 가능. 검색 기능 구현 시 매우 유용 4. 트랜잭션 관리와 REST API 트랜잭션 (Transaction) 정의: &lsquo;모 아니면 도&rsquo;처럼, 모두 성공하거나 모두 실패해야 하는 분리될 수 없는 하나의 작업 단위 ACID 속성: 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 영속성(Durability)을 보장 Spring의 트랜잭션 처리: @Transactional 어노테이션을 서비스 계층 메서드에 추가하면, AOP를 통해 트랜잭션의 시작, 커밋, 롤백이 자동으로 관리됨 REST API와 Ajax REST API: 자원(Resource)을 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)로 해당 자원에 대한 행위를 정의하는 아키텍처 스타일 Ajax: 웹 페이지 전체를 새로고침하지 않고, 백그라운드에서 서버와 데이터를 교환하여 화면 일부만 동적으로 갱신하는 기술 @RestController: @Controller와 @ResponseBody를 합친 것으로, 메서드의 반환 값을 View가 아닌 JSON 등의 데이터 형식으로 반환할 때 사용 마무리 스프링 프레임워크를 적용하게 되면 단순히 코드를 분리하는 것을 넘어, 각 계층의 책임이 명확해지고,\n@Transactional 어노테이션 하나로 서비스 계층의 비즈니스 로직 전체를 원자적 단위로 묶어 처리할 수 있다는 점이\n인상 깊었다.\n">
<meta property='og:url' content='http://localhost:1313/posts/week10-1-retrospective/'>
<meta property='og:site_name' content='Soyeon&#39;s Dev Log'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' /><meta property='article:tag' content='패스트캠퍼스' /><meta property='article:tag' content='커널아카데미' /><meta property='article:tag' content='백엔드개발부트캠프' /><meta property='article:published_time' content='2025-08-23T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2025-08-23T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="[커널아카데미] 백엔드 개발 부트캠프 13기 10주차(1)">
<meta name="twitter:description" content=" 10주차 학습 정리 - 1 이번 주 키워드 Spring DI &amp; AOP Spring MVC 동작 원리 DAO, DTO, Service 계층 분리 MyBatis SQL 매핑 트랜잭션(Transaction) 처리 1. Spring의 핵심 철학: DI와 AOP 의존성 주입 (DI, Dependency Injection) IoC (제어의 역전): 객체의 생성과 생명주기를 개발자가 아닌 스프링 컨테이너(ApplicationContext)가 관리하는 개념 Bean (빈): 스프링 컨테이너가 관리하는 자바 객체(POJO) DI (의존성 주입): 필요한 객체를 직접 생성하지 않고 외부(스프링 컨테이너)에서 주입받는 방식 @Autowired: 타입을 기준으로 빈을 찾아 자동으로 의존성을 주입 @Resource: 이름을 기준으로 빈을 찾아 자동으로 의존성을 주입 @Component: 클래스를 스캔하여 빈으로 자동 등록 관점 지향 프로그래밍 (AOP, Aspect Oriented Programming) AOP: 트랜잭션, 로깅, 보안 등 여러 메서드에 공통적으로 필요한 **부가 기능(횡단 관심사)**을 핵심 비즈니스 로직에서 분리하는 기술 주요 용어: Advice: 부가 기능 자체(코드). Join point: Advice가 적용될 수 있는 위치 (예: 메서드) Pointcut: Advice를 실제로 적용할 Join point를 선별하는 패턴 Weaving: Advice를 핵심 로직에 적용하여 프록시(Proxy) 객체를 만드는 과정 2. Spring MVC 아키텍처 심화 DispatcherServlet: 모든 클라이언트의 요청을 가장 먼저 받아 처리 흐름을 제어하는 중앙 컨트롤러 요청 처리 흐름: 요청 → DispatcherServlet HandlerMapping이 요청 URL에 맞는 Controller 탐색. HandlerAdapter가 Controller의 메서드를 호출 Controller는 비즈니스 로직 처리 후, View 이름과 Model을 반환 ViewResolver가 View 이름을 기반으로 실제 View(JSP 등)를 찾아 렌더링 상태 관리: 쿠키 vs 세션 쿠키(Cookie): 사용자의 정보를 **브라우저(클라이언트)**에 저장하는 작은 데이터 조각 세션(Session): 사용자의 정보를 서버에 저장하고, JSESSIONID 쿠키를 통해 클라이언트를 식별하는 방식 예외 처리 @ExceptionHandler: 컨트롤러 내에서 특정 예외를 처리하는 메서드를 지정 @ControllerAdvice: 여러 컨트롤러에 걸쳐 발생하는 예외를 전역적으로 처리 3. 데이터베이스 연동과 계층형 아키텍처 계층 분리(Layering): 유지보수성과 재사용성을 높이기 위해 코드를 Controller - Service - Repository(DAO) 계층으로 분리 Controller: HTTP 요청/응답 처리 Service: 비즈니스 로직 및 트랜잭션 처리 Repository(DAO): 순수 데이터베이스 접근(CRUD) 담당 DTO (Data Transfer Object): 계층 간 데이터 전송을 위해 사용되는 객체 MyBatis 연동 MyBatis: SQL 쿼리를 Java 코드에서 분리하여 XML 파일(Mapper)로 관리하는 SQL 매핑 프레임워크 SqlSession: SQL 실행에 필요한 메서드(insert, selectOne 등)를 제공하는 핵심 객체 동적 쿼리: &lt;if&gt;, &lt;choose&gt;, &lt;foreach&gt; 등의 태그를 사용해 조건에 따라 SQL을 동적으로 생성 가능. 검색 기능 구현 시 매우 유용 4. 트랜잭션 관리와 REST API 트랜잭션 (Transaction) 정의: &lsquo;모 아니면 도&rsquo;처럼, 모두 성공하거나 모두 실패해야 하는 분리될 수 없는 하나의 작업 단위 ACID 속성: 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 영속성(Durability)을 보장 Spring의 트랜잭션 처리: @Transactional 어노테이션을 서비스 계층 메서드에 추가하면, AOP를 통해 트랜잭션의 시작, 커밋, 롤백이 자동으로 관리됨 REST API와 Ajax REST API: 자원(Resource)을 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)로 해당 자원에 대한 행위를 정의하는 아키텍처 스타일 Ajax: 웹 페이지 전체를 새로고침하지 않고, 백그라운드에서 서버와 데이터를 교환하여 화면 일부만 동적으로 갱신하는 기술 @RestController: @Controller와 @ResponseBody를 합친 것으로, 메서드의 반환 값을 View가 아닌 JSON 등의 데이터 형식으로 반환할 때 사용 마무리 스프링 프레임워크를 적용하게 되면 단순히 코드를 분리하는 것을 넘어, 각 계층의 책임이 명확해지고,\n@Transactional 어노테이션 하나로 서비스 계층의 비즈니스 로직 전체를 원자적 단위로 묶어 처리할 수 있다는 점이\n인상 깊었다.\n"><link rel="alternate" type="application/json" href="http://localhost:1313/posts/week10-1-retrospective/index.json">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="메뉴 여닫기">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/../assets/avatar_hu_6c8b5d6cd0da96b6.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Soyeon&#39;s Dev Log</a></h1>
            <h2 class="site-description">백엔드 개발자 지망생의 기록</h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>다크 모드</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%EA%B3%B5%EB%B6%80/" >
                공부
            </a>
        
            <a href="/categories/%EC%A3%BC%EA%B0%84%ED%9A%8C%EA%B3%A0/" >
                주간회고
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/posts/week10-1-retrospective/">[커널아카데미] 백엔드 개발 부트캠프 13기 10주차(1)</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2025-08-23</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <div style="margin: 0 40px;">
<h1 id="10주차-학습-정리---1">10주차 학습 정리 - 1
</h1><h2 id="이번-주-키워드">이번 주 키워드
</h2><ul>
<li>Spring DI &amp; AOP</li>
<li>Spring MVC 동작 원리</li>
<li>DAO, DTO, Service 계층 분리</li>
<li>MyBatis SQL 매핑</li>
<li>트랜잭션(Transaction) 처리</li>
</ul>
<hr>
<h2 id="1-spring의-핵심-철학-di와-aop">1. Spring의 핵심 철학: DI와 AOP
</h2><h3 id="의존성-주입-di-dependency-injection">의존성 주입 (DI, Dependency Injection)
</h3><ul>
<li><strong>IoC (제어의 역전)</strong>: 객체의 생성과 생명주기를 개발자가 아닌 스프링 컨테이너(<code>ApplicationContext</code>)가 관리하는 개념</li>
<li><strong>Bean (빈)</strong>: 스프링 컨테이너가 관리하는 자바 객체(POJO)</li>
<li><strong>DI (의존성 주입)</strong>: 필요한 객체를 직접 생성하지 않고 외부(스프링 컨테이너)에서 주입받는 방식
<ul>
<li><code>@Autowired</code>: <strong>타입</strong>을 기준으로 빈을 찾아 자동으로 의존성을 주입</li>
<li><code>@Resource</code>: <strong>이름</strong>을 기준으로 빈을 찾아 자동으로 의존성을 주입</li>
<li><code>@Component</code>: 클래스를 스캔하여 빈으로 자동 등록</li>
</ul>
</li>
</ul>
<h3 id="관점-지향-프로그래밍-aop-aspect-oriented-programming">관점 지향 프로그래밍 (AOP, Aspect Oriented Programming)
</h3><ul>
<li><strong>AOP</strong>: 트랜잭션, 로깅, 보안 등 여러 메서드에 공통적으로 필요한 **부가 기능(횡단 관심사)**을 핵심 비즈니스 로직에서 분리하는 기술</li>
<li><strong>주요 용어</strong>:
<ul>
<li><strong>Advice</strong>: 부가 기능 자체(코드).</li>
<li><strong>Join point</strong>: Advice가 적용될 수 있는 위치 (예: 메서드)</li>
<li><strong>Pointcut</strong>: Advice를 실제로 적용할 Join point를 선별하는 패턴</li>
<li><strong>Weaving</strong>: Advice를 핵심 로직에 적용하여 프록시(Proxy) 객체를 만드는 과정</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-spring-mvc-아키텍처-심화">2. Spring MVC 아키텍처 심화
</h2><ul>
<li><strong>DispatcherServlet</strong>: 모든 클라이언트의 요청을 가장 먼저 받아 처리 흐름을 제어하는 <strong>중앙 컨트롤러</strong></li>
<li><strong>요청 처리 흐름</strong>:
<ol>
<li>요청 → <code>DispatcherServlet</code></li>
<li><code>HandlerMapping</code>이 요청 URL에 맞는 <code>Controller</code> 탐색.</li>
<li><code>HandlerAdapter</code>가 <code>Controller</code>의 메서드를 호출</li>
<li><code>Controller</code>는 비즈니스 로직 처리 후, <strong>View 이름</strong>과 <strong>Model</strong>을 반환</li>
<li><code>ViewResolver</code>가 View 이름을 기반으로 실제 View(JSP 등)를 찾아 렌더링</li>
</ol>
</li>
</ul>
<h3 id="상태-관리-쿠키-vs-세션">상태 관리: 쿠키 vs 세션
</h3><ul>
<li><strong>쿠키(Cookie)</strong>: 사용자의 정보를 **브라우저(클라이언트)**에 저장하는 작은 데이터 조각</li>
<li><strong>세션(Session)</strong>: 사용자의 정보를 <strong>서버</strong>에 저장하고, <code>JSESSIONID</code> 쿠키를 통해 클라이언트를 식별하는 방식</li>
</ul>
<h3 id="예외-처리">예외 처리
</h3><ul>
<li><code>@ExceptionHandler</code>: 컨트롤러 내에서 특정 예외를 처리하는 메서드를 지정</li>
<li><code>@ControllerAdvice</code>: 여러 컨트롤러에 걸쳐 발생하는 예외를 전역적으로 처리</li>
</ul>
<hr>
<h2 id="3-데이터베이스-연동과-계층형-아키텍처">3. 데이터베이스 연동과 계층형 아키텍처
</h2><ul>
<li><strong>계층 분리(Layering)</strong>: 유지보수성과 재사용성을 높이기 위해 코드를 <strong>Controller - Service - Repository(DAO)</strong> 계층으로 분리
<ul>
<li><strong>Controller</strong>: HTTP 요청/응답 처리</li>
<li><strong>Service</strong>: 비즈니스 로직 및 트랜잭션 처리</li>
<li><strong>Repository(DAO)</strong>: 순수 데이터베이스 접근(CRUD) 담당</li>
</ul>
</li>
<li><strong>DTO (Data Transfer Object)</strong>: 계층 간 데이터 전송을 위해 사용되는 객체</li>
</ul>
<h3 id="mybatis-연동">MyBatis 연동
</h3><ul>
<li><strong>MyBatis</strong>: SQL 쿼리를 Java 코드에서 분리하여 XML 파일(<code>Mapper</code>)로 관리하는 <strong>SQL 매핑 프레임워크</strong></li>
<li><strong>SqlSession</strong>: SQL 실행에 필요한 메서드(<code>insert</code>, <code>selectOne</code> 등)를 제공하는 핵심 객체</li>
<li><strong>동적 쿼리</strong>: <code>&lt;if&gt;</code>, <code>&lt;choose&gt;</code>, <code>&lt;foreach&gt;</code> 등의 태그를 사용해 조건에 따라 SQL을 동적으로 생성 가능. 검색 기능 구현 시 매우 유용</li>
</ul>
<hr>
<h2 id="4-트랜잭션-관리와-rest-api">4. 트랜잭션 관리와 REST API
</h2><h3 id="트랜잭션-transaction">트랜잭션 (Transaction)
</h3><ul>
<li><strong>정의</strong>: &lsquo;모 아니면 도&rsquo;처럼, 모두 성공하거나 모두 실패해야 하는 <strong>분리될 수 없는 하나의 작업 단위</strong></li>
<li><strong>ACID 속성</strong>: 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 영속성(Durability)을 보장</li>
<li><strong>Spring의 트랜잭션 처리</strong>: <code>@Transactional</code> 어노테이션을 서비스 계층 메서드에 추가하면, AOP를 통해 <strong>트랜잭션의 시작, 커밋, 롤백이 자동으로 관리</strong>됨</li>
</ul>
<h3 id="rest-api와-ajax">REST API와 Ajax
</h3><ul>
<li><strong>REST API</strong>: 자원(Resource)을 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)로 해당 자원에 대한 행위를 정의하는 아키텍처 스타일</li>
<li><strong>Ajax</strong>: 웹 페이지 전체를 새로고침하지 않고, 백그라운드에서 서버와 데이터를 교환하여 화면 일부만 동적으로 갱신하는 기술</li>
<li><code>@RestController</code>: <code>@Controller</code>와 <code>@ResponseBody</code>를 합친 것으로, 메서드의 반환 값을 View가 아닌 JSON 등의 데이터 형식으로 반환할 때 사용</li>
</ul>
<hr>
<h4 id="마무리">마무리
</h4><p>스프링 프레임워크를 적용하게 되면 단순히 코드를 분리하는 것을 넘어, 각 계층의 책임이 명확해지고,<br>
<strong><code>@Transactional</code> 어노테이션 하나로 서비스 계층의 비즈니스 로직 전체를 원자적 단위로 묶어 처리</strong>할 수 있다는 점이<br>
인상 깊었다.<br><br></p>
<p>또한 MyBatis를 통해 SQL 쿼리를 자바 코드와 완전히 분리하면서, 왜 SQL 매퍼 프레임워크가 필요한지를 체감했다.<br>
자바 코드에서는 비즈니스 로직에만 집중하고, SQL은 XML에서 따로 관리하니 가독성과 유지보수성이 크게 향상되었다. <br><br></p>
<p>DI, AOP, 트랜잭션, 계층형 아키텍처 등의 개념들이 스프링이라는 생태계 안에서 어떻게 유기적으로 결합하여 동작하는지를 깨닫게 된 한 주였다.<br>
앞으로는 단순히 기능을 구현하는 것을 넘어, 스프링의 철학을 이해하고 각 기술이 어떤 문제를 해결하기 위해 등장했는지 고민하며 코드를 작성해야겠다고 다짐했다.</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</a>
        
            <a href="/tags/%EC%BB%A4%EB%84%90%EC%95%84%EC%B9%B4%EB%8D%B0%EB%AF%B8/">커널아카데미</a>
        
            <a href="/tags/%EB%B0%B1%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">백엔드개발부트캠프</a>
        
    </section>


    </footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">관련 글</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/posts/week9-retrospective/">
        
        

        <div class="article-details">
            <h2 class="article-title">[커널아카데미] 백엔드 개발 부트캠프 13기 9주차</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/week8-retrospective/">
        
        

        <div class="article-details">
            <h2 class="article-title">[커널아카데미] 백엔드 개발 부트캠프 13기 8주차</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/week7-retrospective/">
        
        

        <div class="article-details">
            <h2 class="article-title">[커널아카데미] 백엔드 개발 부트캠프 13기 7주차</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/week6-retrospective/">
        
        

        <div class="article-details">
            <h2 class="article-title">[커널아카데미] 백엔드 개발 부트캠프 13기 6주차</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/week5-retrospective/">
        
        

        <div class="article-details">
            <h2 class="article-title">[커널아카데미] 백엔드 개발 부트캠프 13기 5주차</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 Soyeon&#39;s Dev Log
    </section>
    
    <section class="powerby">
        <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a>로 만듦 <br />
        <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>의 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 테마 사용 중
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.748d0acf3bd5d18477b5028b83b70ecfa20eb15aefdff97697a330a2202721bf.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
