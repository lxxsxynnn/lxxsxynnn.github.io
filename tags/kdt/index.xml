<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>KDT on Soyeon&#39;s Dev Log</title>
        <link>http://localhost:1313/tags/kdt/</link>
        <description>Recent content in KDT on Soyeon&#39;s Dev Log</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Sat, 20 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/kdt/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>[커널아카데미] 백엔드 개발 부트캠프 13기 CS 정리 - 네트워크 기초와 심화</title>
        <link>http://localhost:1313/posts/week14-retrospective/</link>
        <pubDate>Sat, 20 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/week14-retrospective/</guid>
        <description>&lt;div style=&#34;margin: 0 40px;&#34;&gt;
&lt;h1 id=&#34;네트워크-기초-및-심화-종합-정리&#34;&gt;네트워크 기초 및 심화 종합 정리
&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&#34;1-네트워크란&#34;&gt;1. 네트워크란?
&lt;/h2&gt;&lt;p&gt;컴퓨터와 장치들이 데이터를 주고받는 통신 체계다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LAN(근거리), WAN(광역), 인터넷 등 다양한 형태와 규모가 존재&lt;/li&gt;
&lt;li&gt;주 목적은 원격 자원 접근과 데이터 공유, 통신 서비스 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-네트워크-주요-용어&#34;&gt;2. 네트워크 주요 용어
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;용어&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;IP 주소&lt;/td&gt;
          &lt;td&gt;네트워크 상의 장치 식별을 위한 고유 주소&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;MAC 주소&lt;/td&gt;
          &lt;td&gt;물리적 네트워크 인터페이스의 고유 식별자&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;포트&lt;/td&gt;
          &lt;td&gt;장치 내 서비스 구분을 위한 번호&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;소켓&lt;/td&gt;
          &lt;td&gt;IP 주소와 포트 번호의 조합으로 된 네트워크 통신 종착점&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;패킷&lt;/td&gt;
          &lt;td&gt;네트워크 상 데이터 전송 단위&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;프로토콜&lt;/td&gt;
          &lt;td&gt;통신을 위한 규칙과 절차&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;라우터&lt;/td&gt;
          &lt;td&gt;네트워크 간 데이터 전달 장치&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;스위치&lt;/td&gt;
          &lt;td&gt;같은 네트워크 내 데이터 중계 장치&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;DNS&lt;/td&gt;
          &lt;td&gt;도메인명을 IP 주소로 변환하는 서비스&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-osi-7계층-모델-상세&#34;&gt;3. OSI 7계층 모델 상세
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;계층 번호&lt;/th&gt;
          &lt;th&gt;이름&lt;/th&gt;
          &lt;th&gt;주요 기능 및 설명&lt;/th&gt;
          &lt;th&gt;주요 프로토콜 예&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;응용 계층&lt;/td&gt;
          &lt;td&gt;사용자와 직접 상호작용, 애플리케이션 서비스 제공&lt;/td&gt;
          &lt;td&gt;HTTP, FTP, SMTP, DNS&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;6&lt;/td&gt;
          &lt;td&gt;표현 계층&lt;/td&gt;
          &lt;td&gt;데이터 표현과 암호화, 압축&lt;/td&gt;
          &lt;td&gt;JPEG, ASCII, TLS&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;세션 계층&lt;/td&gt;
          &lt;td&gt;세션 설정, 유지, 종료&lt;/td&gt;
          &lt;td&gt;NetBIOS, SAP&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;전송 계층&lt;/td&gt;
          &lt;td&gt;데이터 전송, 오류 제어, 흐름 제어&lt;/td&gt;
          &lt;td&gt;TCP, UDP&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;네트워크 계층&lt;/td&gt;
          &lt;td&gt;패킷 라우팅, IP 주소 관리&lt;/td&gt;
          &lt;td&gt;IP, ICMP&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;데이터 링크 계층&lt;/td&gt;
          &lt;td&gt;프레임 전송, MAC 주소 관리, 에러 검출 및 수정&lt;/td&gt;
          &lt;td&gt;Ethernet, PPP&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;물리 계층&lt;/td&gt;
          &lt;td&gt;전기 신호, 케이블 등 물리 매체의 실제 전송&lt;/td&gt;
          &lt;td&gt;Ethernet physical, USB&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4-tcpip-4계층-모델-심화&#34;&gt;4. TCP/IP 4계층 모델 심화
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;계층&lt;/th&gt;
          &lt;th&gt;역할&lt;/th&gt;
          &lt;th&gt;상세 원리 및 주요 명령어/프로토콜&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;링크 계층&lt;/td&gt;
          &lt;td&gt;물리 데이터 전송 및 에러 제어&lt;/td&gt;
          &lt;td&gt;Ethernet, Wi-Fi, ARP; 주요 명령어: ifconfig, tcpdump&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;인터넷 계층&lt;/td&gt;
          &lt;td&gt;IP 기반 패킷 전송 및 라우팅&lt;/td&gt;
          &lt;td&gt;IPv4, IPv6, ICMP; 주요 명령어: ping, traceroute&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;전송 계층&lt;/td&gt;
          &lt;td&gt;신뢰성 있는 데이터 전송, 오류 복구&lt;/td&gt;
          &lt;td&gt;TCP(3-way handshake, seq/ack), UDP; netstat 사용&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;응용 계층&lt;/td&gt;
          &lt;td&gt;애플리케이션 서비스 프로토콜&lt;/td&gt;
          &lt;td&gt;HTTP/HTTPS(curl, Postman), FTP, DNS 조회 명령어&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5-ip-주소-및-서브넷팅-상세&#34;&gt;5. IP 주소 및 서브넷팅 상세
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;IPv4: 32bit 주소, 4옥텟으로 표현 (ex. 192.168.0.1)&lt;/li&gt;
&lt;li&gt;서브넷 마스크: 네트워크/호스트 구분 위해 사용&lt;/li&gt;
&lt;li&gt;CIDR 표기법: 192.168.1.0/24 (앞 24비트 네트워크 부분)&lt;/li&gt;
&lt;li&gt;IPv6: 128bit 주소, 넓은 주소 공간과 보안성 강화&lt;/li&gt;
&lt;li&gt;명령어: &lt;code&gt;ipconfig&lt;/code&gt;(Windows), &lt;code&gt;ifconfig&lt;/code&gt;(Linux/Mac), &lt;code&gt;route&lt;/code&gt;, &lt;code&gt;netstat -r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;6-포트와-소켓&#34;&gt;6. 포트와 소켓
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;포트 번호 범위: 0~65535
&lt;ul&gt;
&lt;li&gt;0~1023 웰노운 포트(HTTP 80, HTTPS 443 등)&lt;/li&gt;
&lt;li&gt;1024~49151 등록 포트&lt;/li&gt;
&lt;li&gt;49152~65535 동적/임시 포트&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;소켓 = IP 주소 + 포트 번호 (통신 단위)&lt;/li&gt;
&lt;li&gt;주요 시스템 콜: &lt;code&gt;socket()&lt;/code&gt;, &lt;code&gt;bind()&lt;/code&gt;, &lt;code&gt;listen()&lt;/code&gt;, &lt;code&gt;accept()&lt;/code&gt;, &lt;code&gt;connect()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;소켓 상태: LISTEN, SYN_SENT, ESTABLISHED, CLOSE_WAIT, TIME_WAIT&lt;/li&gt;
&lt;li&gt;명령어 예: &lt;code&gt;netstat -an&lt;/code&gt;, &lt;code&gt;ss -tuln&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;7-httphttps-심화&#34;&gt;7. HTTP/HTTPS 심화
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HTTP: 텍스트 기반 무상태 프로토콜, GET/POST/PUT/DELETE 등 메서드 지원&lt;/li&gt;
&lt;li&gt;HTTPS: TLS/SSL 암호화와 인증서 제공, 데이터 무결성 보장&lt;/li&gt;
&lt;li&gt;HTTP/2: 헤더 압축, 멀티플렉싱, 서버 푸시&lt;/li&gt;
&lt;li&gt;HTTP/3(QUIC): UDP 기반, 저지연 통신&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;8-네트워크-통신-흐름-심화&#34;&gt;8. 네트워크 통신 흐름 심화
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;클라이언트가 도메인명으로 DNS 질의&lt;/li&gt;
&lt;li&gt;DNS가 IP 주소 반환&lt;/li&gt;
&lt;li&gt;TCP 3-way handshake로 연결 수립&lt;/li&gt;
&lt;li&gt;HTTP 요청 및 응답 교환&lt;/li&gt;
&lt;li&gt;(HTTPS) TLS 인증서 교환 및 암호화 과정&lt;/li&gt;
&lt;li&gt;연결 유지 혹은 종료(Keep-Alive 옵션)&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;9-nat와-포트포워딩&#34;&gt;9. NAT와 포트포워딩
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;NAT: 사설 IP주소를 공인 IP주소로 변환, 네트워크 보안 및 주소 절약 목적&lt;/li&gt;
&lt;li&gt;포트포워딩: 외부 요청을 내부 네트워크 특정 IP 및 포트로 전달&lt;/li&gt;
&lt;li&gt;방화벽과 병행해 서비스 접근을 제어함&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;10-실무와-면접-팁&#34;&gt;10. 실무와 면접 팁
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TCP와 UDP의 특징과 용도 차이 숙지&lt;/li&gt;
&lt;li&gt;방화벽, NAT 문제 발생 시 해결법 익히기&lt;/li&gt;
&lt;li&gt;SSL/TLS 인증서 설정 시 유의점과 절차 이해&lt;/li&gt;
&lt;li&gt;CORS 정책 문제 이해 및 해결 방법&lt;/li&gt;
&lt;li&gt;소켓 프로그래밍 API 이해 및 활용&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;11-확장-및-응용-사례&#34;&gt;11. 확장 및 응용 사례
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;RESTful API와 GraphQL의 네트워크 차이&lt;/li&gt;
&lt;li&gt;WebSocket 기반 양방향 실시간 통신 설계 및 구현&lt;/li&gt;
&lt;li&gt;스프링 WebFlux를 활용한 리액티브 네트워크 프로그래밍 이해&lt;/li&gt;
&lt;li&gt;로드밸런싱 및 네트워크 보안 기법&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;12-주요-명령어-및-코드-예제&#34;&gt;12. 주요 명령어 및 코드 예제
&lt;/h2&gt;&lt;h3 id=&#34;네트워크-주요-명령어&#34;&gt;네트워크 주요 명령어
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ipconfig          &lt;span style=&#34;color:#75715e&#34;&gt;# 윈도우 IP 정보&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ifconfig          &lt;span style=&#34;color:#75715e&#34;&gt;# 리눅스/Mac IP 정보&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ping google.com   &lt;span style=&#34;color:#75715e&#34;&gt;# 연결 테스트&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;traceroute google.com  &lt;span style=&#34;color:#75715e&#34;&gt;# 리눅스 경로 추적&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tracert google.com     &lt;span style=&#34;color:#75715e&#34;&gt;# 윈도우 경로 추적&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;netstat -an       &lt;span style=&#34;color:#75715e&#34;&gt;# 소켓 및 포트 상태&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ss -tuln          &lt;span style=&#34;color:#75715e&#34;&gt;# 리눅스 소켓 상세 정보&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nslookup example.com   &lt;span style=&#34;color:#75715e&#34;&gt;# DNS 조회&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;java-tcp-서버-예제&#34;&gt;Java TCP 서버 예제
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.*;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.net.*;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TcpServer&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; IOException {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ServerSocket serverSocket &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServerSocket(5000);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;서버 대기 중...&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Socket clientSocket &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; serverSocket.&lt;span style=&#34;color:#a6e22e&#34;&gt;accept&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        BufferedReader in &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; BufferedReader(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; InputStreamReader(clientSocket.&lt;span style=&#34;color:#a6e22e&#34;&gt;getInputStream&lt;/span&gt;()));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        PrintWriter out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; PrintWriter(clientSocket.&lt;span style=&#34;color:#a6e22e&#34;&gt;getOutputStream&lt;/span&gt;(), &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String line;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; ((line &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; in.&lt;span style=&#34;color:#a6e22e&#34;&gt;readLine&lt;/span&gt;()) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;클라이언트: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; line);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            out.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;echo: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; line);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bye&amp;#34;&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;equalsIgnoreCase&lt;/span&gt;(line)) &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        clientSocket.&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        serverSocket.&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;java-tcp-클라이언트-예제&#34;&gt;Java TCP 클라이언트 예제
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.*;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.net.*;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TcpClient&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; IOException {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Socket socket &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Socket(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;, 5000);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        BufferedReader keyboard &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; BufferedReader(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; InputStreamReader(System.&lt;span style=&#34;color:#a6e22e&#34;&gt;in&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        PrintWriter out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; PrintWriter(socket.&lt;span style=&#34;color:#a6e22e&#34;&gt;getOutputStream&lt;/span&gt;(), &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        BufferedReader in &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; BufferedReader(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; InputStreamReader(socket.&lt;span style=&#34;color:#a6e22e&#34;&gt;getInputStream&lt;/span&gt;()));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String userInput;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; ((userInput &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; keyboard.&lt;span style=&#34;color:#a6e22e&#34;&gt;readLine&lt;/span&gt;()) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            out.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(userInput);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;서버 응답: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; in.&lt;span style=&#34;color:#a6e22e&#34;&gt;readLine&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bye&amp;#34;&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;equalsIgnoreCase&lt;/span&gt;(userInput)) &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        socket.&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;13-네트워크-통신-과정-도식화&#34;&gt;13. 네트워크 통신 과정 도식화
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[Application Layer (HTTP/FTP 등)]
      ↓
[Transport Layer (TCP/UDP) - 3-way Handshake]
      ↓
[Internet Layer (IP, 라우팅)]
      ↓
[Data Link Layer (MAC, 프레임)]
      ↓
[Physical Layer (전기 신호, 케이블)]
      ↓
(물리 전송 매체 → 수신 측은 역순으로 헤더 해체 후 응용까지 전달)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
</description>
        </item>
        <item>
        <title>[커널아카데미] 백엔드 개발 부트캠프 13기 13주차</title>
        <link>http://localhost:1313/posts/week13-retrospective/</link>
        <pubDate>Sun, 14 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/week13-retrospective/</guid>
        <description>&lt;div style=&#34;margin: 0 40px;&#34;&gt;
&lt;h1 id=&#34;13주차-학습정리---운영체제&#34;&gt;13주차 학습정리 - 운영체제
&lt;/h1&gt;&lt;h2 id=&#34;1-정의와-목적&#34;&gt;1. 정의와 목적
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;운영체제(OS)&lt;/strong&gt;: 컴퓨터의 하드웨어 및 소프트웨어 자원을 관리·제어하고,&lt;br&gt;
사용자와 응용 프로그램에 대해 통합적·효율적 서비스를 제공하는 시스템 소프트웨어&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;대표 예시&lt;/strong&gt;: Windows, macOS, Linux, Android, iOS 등&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-구성과-구조&#34;&gt;2. 구성과 구조
&lt;/h2&gt;&lt;h3 id=&#34;전체-구조&#34;&gt;전체 구조
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;하드웨어&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;커널(Kernel)&lt;/strong&gt;: OS의 핵심, 자원관리·프로세스·메모리·파일·I/O 등 주요기능 수행&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;셸(Shell)&lt;/strong&gt;: 사용자 인터페이스(터미널·명령어·그래픽 등)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;응용프로그램/App&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;사용자 및 외부장치&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;계층-관계도식&#34;&gt;계층 관계(도식)
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[사용자]
  |
[셸/앱]
  |
[운영체제(OS) - 커널]
  |
[하드웨어 (CPU, 메모리, 디스크, 네트워크, I/O장치)]
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;3-핵심-역할과-기능&#34;&gt;3. 핵심 역할과 기능
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;자원 관리(Resource Management)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU, 메모리, 저장장치, 입출력장치 등 자원 배분·제어[1]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;프로세스/스레드 관리(Process/Thread Management)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행중인 프로그램, 스케줄링(순서관리), 생성/종료/상태관리&lt;/li&gt;
&lt;li&gt;멀티태스킹 지원(동시 실행 효과)&lt;/li&gt;
&lt;li&gt;스레드 : 내부 작업단위, 메모리 공유&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;메모리 관리(Memory Management)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로세스/프로그램별 메모리 할당/회수/배치&lt;/li&gt;
&lt;li&gt;가상 메모리, 페이징 등 효율화 기법&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;파일 시스템 관리(File System Management)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터 저장/읽기/삭제, 파일·디렉토리 구조 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;입출력(I/O) 및 장치관리&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;키보드, 마우스, 프린터, 디스플레이 등 연결·제어&lt;/li&gt;
&lt;li&gt;드라이버(Driver) 통한 하드웨어/OS 연동&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;보안 및 권한(Security &amp;amp; Authorization)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자원 접근권한, 사용자 인증, 데이터 보호&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;네트워킹&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시스템 간 통신, 네트워크 자원 관리(소켓, TCP/IP)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;시스템 서비스 및 API&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;응용프로그램이 OS 서비스 이용할 수 있도록 시스템콜 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4-용어-및-주요-원리&#34;&gt;4. 용어 및 주요 원리
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;용어&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;커널&lt;/td&gt;
          &lt;td&gt;OS 핵심, 자원·스케줄링·메모리 관리&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;셸&lt;/td&gt;
          &lt;td&gt;사용자와 OS간 인터페이스 (명령/그래픽 등)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;프로세스&lt;/td&gt;
          &lt;td&gt;실행중인 프로그램 인스턴스&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;스레드&lt;/td&gt;
          &lt;td&gt;프로세스 내 작업 실행 단위&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;시스템콜&lt;/td&gt;
          &lt;td&gt;프로그램↔OS 인터페이스용 함수&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;드라이버&lt;/td&gt;
          &lt;td&gt;하드웨어↔OS 연동 소프트웨어&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;파일 시스템&lt;/td&gt;
          &lt;td&gt;저장·검색·구조화·삭제를 위한 OS 서비스&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;가상 메모리&lt;/td&gt;
          &lt;td&gt;실제·논리 메모리 분리, 효율증대&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;멀티태스킹&lt;/td&gt;
          &lt;td&gt;여러 앱·프로세스를 동시에 실행&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5-os-종류와-특징&#34;&gt;5. OS 종류와 특징
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;데스크탑/서버 OS&lt;/strong&gt;: Windows, macOS, Linux (다중 사용자/프로세스, 보안기능↑)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;모바일/임베디드 OS&lt;/strong&gt;: Android, iOS, RTOS 등 (경량화, 실시간 처리, 장치특화)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기타&lt;/strong&gt;: UNIX, BSD, 하이퍼바이저(가상화 OS)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;6-프로세스-관리와-문맥-전환&#34;&gt;6. 프로세스 관리와 문맥 전환
&lt;/h2&gt;&lt;h3 id=&#34;프로세스process와-스레드thread의-차이&#34;&gt;프로세스(Process)와 스레드(Thread)의 차이
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;프로세스&lt;/strong&gt;: 실행 중인 프로그램의 인스턴스, 별도의 메모리 공간과 자원을 가짐&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스레드&lt;/strong&gt;: 프로세스 내 실행 단위, 프로세스 자원(메모리, 변수)을 공유&lt;/li&gt;
&lt;li&gt;프로세스 간 독립성 높고, 스레드는 경량 프로세스라고도 불림&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;문맥-전환context-switching&#34;&gt;문맥 전환(Context Switching)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CPU가 한 프로세스에서 다른 프로세스로 전환할 때 이전 프로세스 상태(레지스터, PC 등)를 저장하고,&lt;br&gt;
다음 프로세스 상태를 복원하는 작업&lt;/li&gt;
&lt;li&gt;비용이 크고 빈번한 전환은 성능 저하 원인&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pcbprocess-control-block&#34;&gt;PCB(Process Control Block)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;각 프로세스의 상태와 정보(프로세스 ID, 상태, 레지스터, 메모리 정보, 스케줄링 정보 등)를 저장하는 데이터 구조&lt;/li&gt;
&lt;li&gt;OS는 PCB를 이용해 프로세스 실행 상태 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;프로세스-상태-변화-예시&#34;&gt;프로세스 상태 변화 예시
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;대기(Ready) → 실행(Running) → 대기(Waiting) → 종료(Terminated)&lt;/li&gt;
&lt;li&gt;상태 전이 시 PCB 업데이트와 문맥 전환 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;7-스케줄링-알고리즘&#34;&gt;7. 스케줄링 알고리즘
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;알고리즘&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;장점&lt;/th&gt;
          &lt;th&gt;단점&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;FCFS&lt;/td&gt;
          &lt;td&gt;먼저 온 요청부터 처리&lt;/td&gt;
          &lt;td&gt;구현 단순, 공정함&lt;/td&gt;
          &lt;td&gt;긴 작업이 전체 대기 시간 증가(Convoy 효과)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SJF&lt;/td&gt;
          &lt;td&gt;실행 시간이 짧은 작업 먼저 처리&lt;/td&gt;
          &lt;td&gt;평균 대기시간 최소화&lt;/td&gt;
          &lt;td&gt;긴 작업이 무한 대기 가능(Starvation)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Priority&lt;/td&gt;
          &lt;td&gt;우선순위 높은 작업 먼저 처리&lt;/td&gt;
          &lt;td&gt;중요한 작업 우선 수행 가능&lt;/td&gt;
          &lt;td&gt;낮은 우선순위 작업 무한대기 위험&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RR (Round Robin)&lt;/td&gt;
          &lt;td&gt;정해진 시간으로 순환&lt;/td&gt;
          &lt;td&gt;공평한 CPU 시간 분배&lt;/td&gt;
          &lt;td&gt;짧은 시간 할당 시 문맥 전환 과다&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;멀티레벨 큐&lt;/td&gt;
          &lt;td&gt;여러 큐로 작업 분리, 각 큐별 스케줄링&lt;/td&gt;
          &lt;td&gt;다양한 우선순위/형태 지원&lt;/td&gt;
          &lt;td&gt;복잡한 관리, 프로세스 이동 정책 필요&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;실무-시스템서버-적용-사례&#34;&gt;실무 시스템/서버 적용 사례
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;서버는 RR 기반 멀티태스킹+우선순위 혼합 적용&lt;/li&gt;
&lt;li&gt;실시간 시스템은 Priority 스케줄링 혹은 Rate-monotonic&lt;/li&gt;
&lt;li&gt;대형 OS(리눅스 등)는 멀티레벨 피드백 큐 스케줄링 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;8-메모리-관리&#34;&gt;8. 메모리 관리
&lt;/h2&gt;&lt;h3 id=&#34;기본-개념&#34;&gt;기본 개념
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;메모리 주소를 효율적으로 할당·회수하고 보호&lt;/li&gt;
&lt;li&gt;실제 물리 메모리와 가상 메모리를 분리해 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;페이징paging&#34;&gt;페이징(Paging)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;메모리를 고정 크기 블록(페이지)으로 분리하여 할당&lt;/li&gt;
&lt;li&gt;페이지 단위로 물리 메모리 대응, 내부 단편화 최소화&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;세그먼테이션segmentation&#34;&gt;세그먼테이션(Segmentation)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;프로그램을 의미 단위(코드, 데이터, 스택 등)로 분할하여 관리&lt;/li&gt;
&lt;li&gt;논리적 구조 반영이 용이하나 외부 단편화 발생 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;가상-메모리&#34;&gt;가상 메모리
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;실제 메모리보다 큰 메모리 공간 제공&lt;/li&gt;
&lt;li&gt;필요시 디스크에 ‘스왑(swapping)’하여 메모리 부족 해소&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;페이지-폴트page-fault&#34;&gt;페이지 폴트(Page Fault)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;페이지가 메모리에 없을 때 발생하는 인터럽트&lt;/li&gt;
&lt;li&gt;OS가 디스크에서 적절한 페이지를 메모리로 로드&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;현대-os-메모리-관리-사례&#34;&gt;현대 OS 메모리 관리 사례
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;요구 페이징, 메모리 보호, 공유 메모리, 메모리 매핑 파일&lt;/li&gt;
&lt;li&gt;리눅스, 윈도우 등에서 다양한 기법 조합 적용&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;9-동기화와-병행성&#34;&gt;9. 동기화와 병행성
&lt;/h2&gt;&lt;h3 id=&#34;임계-구역critical-section&#34;&gt;임계 구역(Critical Section)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;다중 스레드가 동시에 접근 시 문제가 생기는 공유 자원 접근 구간&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동기화-도구&#34;&gt;동기화 도구
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;뮤텍스(Mutex)&lt;/strong&gt;: 상호 배제 자원 잠금&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;세마포어(Semaphore)&lt;/strong&gt;: 자원 수 계산 및 접근 제한&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;모니터(Monitor)&lt;/strong&gt;: 뮤텍스+조건변수, 구조화된 동기화 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동기화-필요-이유&#34;&gt;동기화 필요 이유
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;데이터 일관성 및 무결성 보장을 위해 필수&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동기화-문제점&#34;&gt;동기화 문제점
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;데드락(Deadlock) : 자원 순환 대기로 작업 정지&lt;/li&gt;
&lt;li&gt;라이브락(Livelock) : 반복 응답하지만 처리 못함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;병행-프로그래밍-실전&#34;&gt;병행 프로그래밍 실전
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;적절한 락 사용, 최소화&lt;/li&gt;
&lt;li&gt;불변 객체 활용&lt;/li&gt;
&lt;li&gt;원자성 보장 코드 작성&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;10-파일-시스템&#34;&gt;10. 파일 시스템
&lt;/h2&gt;&lt;h3 id=&#34;파일-시스템-원리&#34;&gt;파일 시스템 원리
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;데이터 저장소를 파일과 폴더 구조로 추상화하여 관리&lt;/li&gt;
&lt;li&gt;데이터 추가, 삭제, 검색 기능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-시스템-종류&#34;&gt;파일 시스템 종류
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;FAT(File Allocation Table): 간단, 플로피 디스크용&lt;/li&gt;
&lt;li&gt;NTFS(New Technology File System): 윈도우 주력&lt;/li&gt;
&lt;li&gt;ext3, ext4: 리눅스에서 널리 사용하는 저널링 파일 시스템&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-입출력-및-권한-관리&#34;&gt;파일 입출력 및 권한 관리
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;OS API 통해 파일 열기, 읽기, 쓰기, 닫기 수행&lt;/li&gt;
&lt;li&gt;권한은 소유자, 그룹, 기타 사용자 별로 읽기, 쓰기, 실행 구분&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;정리&#34;&gt;정리
&lt;/h1&gt;&lt;p&gt;운영체제의 핵심 기능인 프로세스와 스레드 관리, 문맥 전환을 이해하고 스케줄링 알고리즘을 익히는 것은&lt;br&gt;
효율적인 CPU 사용과 멀티태스킹 구현의 기본&lt;/p&gt;
&lt;p&gt;메모리 관리 기법 - 자원 최적화와 시스템 안정성에 직결&lt;br&gt;
동기화 이슈 - 병행 처리에서 데이터 일관성을 보장하는 필수 요소&lt;/p&gt;
&lt;p&gt;파일 시스템 - 영속적 데이터 저장과 관리의 근간으로, 운영체제 전반의 이해를 완성하는 중요한 주제&lt;/p&gt;
&lt;/div&gt;
</description>
        </item>
        <item>
        <title>[커널아카데미] 백엔드 개발 부트캠프 13기 12주차</title>
        <link>http://localhost:1313/posts/week12-retrospective/</link>
        <pubDate>Sun, 07 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/week12-retrospective/</guid>
        <description>&lt;div style=&#34;margin: 0 40px;&#34;&gt;
&lt;h1 id=&#34;12주차-학습-정리---spring-ai--tcpip&#34;&gt;12주차 학습 정리 - Spring AI &amp;amp; TCP/IP
&lt;/h1&gt;&lt;h2 id=&#34;이번-주-키워드&#34;&gt;이번 주 키워드
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Spring AI 프레임워크&lt;/li&gt;
&lt;li&gt;생성형 AI와 LLM 연동(RAG, Tool Calling)&lt;/li&gt;
&lt;li&gt;Spring Boot와 AI 통합&lt;/li&gt;
&lt;li&gt;TCP/IP 네트워크 기초와 실무&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-spring-ai란&#34;&gt;1. Spring AI란?
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Spring AI&lt;/strong&gt;는 자바 기반 스프링 생태계에서 생성형 AI 기능(LLM, 벡터DB 등)을 쉽고 일관되게 활용할 수 있도록 만든 프레임워크&lt;/li&gt;
&lt;li&gt;OpenAI, Anthropic, Microsoft, Google 등 주요 AI 모델 및 Chroma, Pinecone 등 여러 벡터DB와 빠르게 연동 가능&lt;/li&gt;
&lt;li&gt;기존 Spring Boot 환경에 &lt;strong&gt;자동 구성(Auto Configuration)&lt;/strong&gt;, 다양한 &lt;strong&gt;LLM API 지원&lt;/strong&gt;, &lt;strong&gt;RAG(검색 증강 생성)&lt;/strong&gt;,&lt;br&gt;
&lt;strong&gt;툴 콜링&lt;/strong&gt;, &lt;strong&gt;실시간 스트리밍 API&lt;/strong&gt; 등 최신 AI 관련 기능을 간단하게 추가 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-spring-ai의-주요-특징&#34;&gt;2. Spring AI의 주요 특징
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;자동 설정 &amp;amp; 스타터 의존성&lt;/strong&gt;: 복잡한 설정 없이 거의 바로 서비스 개발이 가능&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;다양한 AI/데이터베이스 연동&lt;/strong&gt;: 주요 AI 모델, 문서·테이블 기반 RAG 시스템, 실시간 챗봇 등 빠르게 구현&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;툴 호출 기능&lt;/strong&gt;: AI가 실시간으로 클라이언트 함수나 외부 API를 직접 실행할 수 있음&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;출력 매핑·스트리밍 지원&lt;/strong&gt;: 생성형 응답을 자바 객체(POJO)로 바로 연결, 대형 모델 응답 스트리밍까지 지원&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;실무 활용 예시&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;내 문서/PDF 기반 QnA 챗봇&lt;/li&gt;
&lt;li&gt;외부 API 연동형 생성형 응답 서비스&lt;/li&gt;
&lt;li&gt;데이터베이스 문서 검색 + RAG&lt;/li&gt;
&lt;li&gt;AI 결과 실시간 모니터링(Actuator, Observability)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-tcpip-네트워크-기초&#34;&gt;3. TCP/IP 네트워크 기초
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TCP/IP 4계층 모델&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Network Interface: 실제 신호 전달(Ethernet, MAC)&lt;/li&gt;
&lt;li&gt;Internet(IP): 패킷 라우팅, 경로 지정&lt;/li&gt;
&lt;li&gt;Transport(TCP/UDP):
&lt;ul&gt;
&lt;li&gt;TCP: 신뢰성, 순서 보장, 패킷 재전송, 오류 검출&lt;/li&gt;
&lt;li&gt;UDP: 비신뢰, 빠른 전송&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Application Layer: HTTP, FTP, WebSocket 등 실제 서비스&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;작동 흐름&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;송신: Application 계층(HTTP 등) → Transport(TCP: 포트) → Internet(IP) → Network Interface로 캡슐화&lt;/li&gt;
&lt;li&gt;수신: 반대로 해체(역캡슐화)해 최종 Application 데이터로&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot/Spring AI 연동에 미치는 영향&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 REST API/LLM 챗봇/WebSocket 등은 실제로 TCP/IP로 연결됨&lt;/li&gt;
&lt;li&gt;HTTPS, WSS(WebSocket Secure)=TCP 기반 암호화 프로토콜&lt;/li&gt;
&lt;li&gt;서버/클라이언트가 도메인, 포트, 프로토콜이 다르면 인증서, CORS, Origin 등의 네트워크/보안 설정을 항상 신경 써야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4-배운-점--느낀-점&#34;&gt;4. 배운 점 &amp;amp; 느낀 점
&lt;/h2&gt;&lt;p&gt;지금 진행 중인 토이 프로젝트 배포 환경에서 프론트엔드와 백엔드 도메인이 달라서&lt;br&gt;
CORS 에러, 인증서 적용, 보안 정책 등 여러 네트워크 문제를 직접 경험했다.&lt;br&gt;
기존에는 http로만 단순히 API를 연결하는 게 전부처럼 느껴졌지만,&lt;br&gt;
실제로 안정적인 서비스와 실시간 통신을 지원하려면&lt;br&gt;
&lt;strong&gt;TCP/IP와 애플리케이션 계층(HTTP, WSS 등)의 동작 원리까지 제대로 이해하는 게 필수&lt;/strong&gt;라는 점을 절실히 알게 되었다.&lt;/p&gt;
&lt;p&gt;이번에 Spring AI를 배우면서, 단순히 최신 프레임워크만 다루는 게 아니라&lt;br&gt;
서버와 클라이언트가 어떻게 서로 데이터를 주고받고, 네트워크 내부에서 어떤 문제가 발생할 수 있는지&lt;br&gt;
그리고 그 문제를 제대로 해결하기 위해서는 &lt;strong&gt;기초가 되는 TCP/IP와 같은 네트워크 구조까지 함께 신경 쓰는 것이 중요&lt;/strong&gt;하다는 사실을 다시 깨달았다.&lt;/p&gt;
&lt;p&gt;Spring Boot와 Spring AI가 제공하는 높은 개발 생산성과 편의성에 기대는 것도 좋지만,&lt;br&gt;
결국 실무에서는 &lt;strong&gt;네트워크 구조, 보안, 통신 정책까지 꼼꼼히 신경 써야 제대로 동작하는 백엔드 서비스&lt;/strong&gt;를 만들 수 있다는 점을 이번 주에 깊이 인식했다.&lt;/p&gt;
&lt;/div&gt;
</description>
        </item>
        <item>
        <title>[커널아카데미] 백엔드 개발 부트캠프 13기 8주차</title>
        <link>http://localhost:1313/posts/week8-retrospective/</link>
        <pubDate>Sun, 10 Aug 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/week8-retrospective/</guid>
        <description>&lt;div style=&#34;margin: 0 40px;&#34;&gt;
&lt;h1 id=&#34;이펙티브-자바&#34;&gt;이펙티브 자바
&lt;/h1&gt;&lt;h2 id=&#34;1-생성자-대신-정적-팩터리-메서드를-고려하라&#34;&gt;1. 생성자 대신 정적 팩터리 메서드를 고려하라
&lt;/h2&gt;&lt;h3 id=&#34;장점&#34;&gt;장점
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;이름 부여&lt;/strong&gt;: 반환 목적, 특징을 이름에 반영 가능 (&lt;code&gt;of()&lt;/code&gt;, &lt;code&gt;valueOf()&lt;/code&gt;, &lt;code&gt;from()&lt;/code&gt; 등)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인스턴스 재사용&lt;/strong&gt;: 반드시 새 객체가 필요하지 않다면 캐시·싱글턴 등으로 같은 객체를 재사용할 수 있음 (성능·메모리 절약, ex. &lt;code&gt;Boolean.valueOf&lt;/code&gt;, &lt;code&gt;Integer.valueOf&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인스턴스 통제&lt;/strong&gt;: 싱글턴, 불변 값 객체, 인스턴스화 불가능 객체(팩터리 메서드만 제공) 등 다양한 객체 관리 전략을 구현하기 쉬움&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;반환 타입 유연성&lt;/strong&gt;: 팩터리 메서드의 반환타입은 하위타입까지 포함할 수 있어 확장성이 높음 (ex. 인터페이스 반환, 다양한 구현체 숨김)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;구현 클래스 은닉&lt;/strong&gt;: API 바깥에 구체 구현 클래스를 노출하지 않고도 객체를 반환할 수 있음 (ex. 컬렉션 프레임워크의 &lt;code&gt;List.of&lt;/code&gt; 등)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;다양한 반환&lt;/strong&gt;: 입력값에 따라 서로 다른 클래스의 객체를 반환할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;상속 제약&lt;/strong&gt;: &lt;code&gt;public&lt;/code&gt;/&lt;code&gt;protected&lt;/code&gt; 생성자가 없으므로 하위 클래스를 만들 수 없음 (확장 불가)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;호출 가시성↓&lt;/strong&gt;: 사용자가 ‘생성자’로 객체를 찾는 습성 때문에, 정적 팩터리 메서드의 존재가 눈에 덜 띌 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-생성자에-매개변수가-많다면-빌더-패턴을-고려하라&#34;&gt;2. 생성자에 매개변수가 많다면 빌더 패턴을 고려하라
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;점층적 생성자 패턴은 매개변수가 많아지면 난해&lt;/li&gt;
&lt;li&gt;자바빈즈 패턴(setter)은 객체 일관성 깨짐 위험&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;빌더 패턴&lt;/strong&gt;: 필수 매개변수는 생성자/정적 메서드, 선택 매개변수는 빌더 메서드 체이닝, 마지막에 &lt;code&gt;build()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MyObj obj &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MyObj.&lt;span style=&#34;color:#a6e22e&#34;&gt;builder&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;필수1&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;필수2&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 .&lt;span style=&#34;color:#a6e22e&#34;&gt;optionA&lt;/span&gt;(123)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 .&lt;span style=&#34;color:#a6e22e&#34;&gt;optionB&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 .&lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;3-싱글턴을-보증하는-방법&#34;&gt;3. 싱글턴을 보증하는 방법
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;private 생성자 + public static final 필드&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Singleton INSTANCE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Singleton();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt;() {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;private 생성자 + public static 팩터리&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Singleton INSTANCE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Singleton();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt;() {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton &lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;() { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; INSTANCE; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;enum 사용&lt;/strong&gt; (가장 안전)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; Singleton {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    INSTANCE;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;4-인스턴스-생성을-막고-싶다면-private-생성자를-사용&#34;&gt;4. 인스턴스 생성을 막고 싶다면 private 생성자를 사용
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;추상클래스만으로는 인스턴스 생성 차단 불가&lt;/li&gt;
&lt;li&gt;반드시 &lt;code&gt;private&lt;/code&gt; 생성자 명시&lt;/li&gt;
&lt;li&gt;유틸리티 클래스(정적 메서드만 모은 클래스)에서 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5-의존-객체-주입dependency-injection-활용&#34;&gt;5. 의존 객체 주입(Dependency Injection) 활용
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;자원 변경이 필요한 경우 정적 유틸리티/싱글턴은 부적합&lt;/li&gt;
&lt;li&gt;생성자 / 세터 / 인터페이스 / 람다 / 팩터리 등으로 주입&lt;/li&gt;
&lt;li&gt;Mock 객체나 대체 구현체로 테스트 용이성 확보&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;6-불필요한-객체-생성-피하기&#34;&gt;6. 불필요한 객체 생성 피하기
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;불변 객체·캐시 재사용&lt;/li&gt;
&lt;li&gt;값 비교시 &lt;code&gt;==&lt;/code&gt; 사용&lt;/li&gt;
&lt;li&gt;박싱/오토박싱 주의&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;7-다-쓴-객체-참조-해제-메모리-누수-예방&#34;&gt;7. 다 쓴 객체 참조 해제: 메모리 누수 예방
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;직접 메모리 관리 클래스(컬렉션, 캐시 등): 사용 후 참조 해제(&lt;code&gt;null&lt;/code&gt;, 삭제 등)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WeakHashMap&lt;/code&gt;, &lt;code&gt;LinkedHashMap&lt;/code&gt;, &lt;code&gt;java.lang.ref&lt;/code&gt; 활용 가능&lt;/li&gt;
&lt;li&gt;참조변수를 유효 범위 밖으로 밀어내기&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;8-결합도와-객체-생성-방식-비교&#34;&gt;8. 결합도와 객체 생성 방식 비교
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;방식&lt;/th&gt;
          &lt;th&gt;결합도&lt;/th&gt;
          &lt;th&gt;확장/유연성&lt;/th&gt;
          &lt;th&gt;테스트 용이성&lt;/th&gt;
          &lt;th&gt;대표 사례&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;직접 생성&lt;/td&gt;
          &lt;td&gt;강함(Tight)&lt;/td&gt;
          &lt;td&gt;낮음&lt;/td&gt;
          &lt;td&gt;어려움&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;new MyObj(...)&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;팩토리 패턴&lt;/td&gt;
          &lt;td&gt;느슨함(Loose)&lt;/td&gt;
          &lt;td&gt;높음&lt;/td&gt;
          &lt;td&gt;좋음&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;new MyObj(factory)&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;람다/함수식 주입&lt;/td&gt;
          &lt;td&gt;매우 느슨함&lt;/td&gt;
          &lt;td&gt;매우 높음&lt;/td&gt;
          &lt;td&gt;매우 좋음&lt;/td&gt;
          &lt;td&gt;Java 8+ Supplier 등&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;9-equals와-hashcode&#34;&gt;9. equals와 hashCode
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;논리적 동치 비교 필요 시 규약 준수하여 재정의 필수&lt;/li&gt;
&lt;li&gt;hashCode 불일치 시 HashSet/HashMap 등에서 문제 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;10-클래스와-멤버-접근-권한-최소화&#34;&gt;10. 클래스와 멤버 접근 권한 최소화
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;public 가변 필드 → Thread-Safety 문제&lt;/li&gt;
&lt;li&gt;내부 구현 최대한 은닉, API 최소 공개&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;디자인-패턴&#34;&gt;디자인 패턴
&lt;/h1&gt;&lt;h2 id=&#34;객체-재사용-패턴&#34;&gt;객체 재사용 패턴
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;패턴&lt;/th&gt;
          &lt;th&gt;목적&lt;/th&gt;
          &lt;th&gt;특징/주요 역할&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Singleton&lt;/td&gt;
          &lt;td&gt;객체 1개만 생성·재사용&lt;/td&gt;
          &lt;td&gt;전역 인스턴스, 상태 공유&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Flyweight&lt;/td&gt;
          &lt;td&gt;객체 여러 개를 공유해 재사용&lt;/td&gt;
          &lt;td&gt;메모리 절약, 상태 최소화&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Prototype&lt;/td&gt;
          &lt;td&gt;객체 복제(Cloning)&lt;/td&gt;
          &lt;td&gt;clone/factory 기반 효율적 생성&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Builder&lt;/td&gt;
          &lt;td&gt;복잡한 객체 생성&lt;/td&gt;
          &lt;td&gt;선택·필수 매개변수 분리, 조립식 생성&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Iterator&lt;/td&gt;
          &lt;td&gt;컬렉션 순회 책임 분리&lt;/td&gt;
          &lt;td&gt;내부 구조 노출 없이 순회&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;행위--구조-분리-패턴&#34;&gt;행위 &amp;amp; 구조 분리 패턴
&lt;/h2&gt;&lt;h3 id=&#34;template-method&#34;&gt;Template Method
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;추상클래스에서 알고리즘 구조를 정의, 하위클래스가 세부 구현&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;AbstractList&lt;/code&gt;, &lt;code&gt;AbstractCollection&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;strategy&#34;&gt;Strategy
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;알고리즘을 객체로 분리, 런타임에 주입&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;Comparator&lt;/code&gt;, &lt;code&gt;Collections.sort&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bridge&#34;&gt;Bridge
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;구현부와 추상부를 분리해 독립 확장 가능&lt;/li&gt;
&lt;li&gt;예: JDBC Driver 구조&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;생성구조행위-패턴&#34;&gt;생성/구조/행위 패턴
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;패턴&lt;/th&gt;
          &lt;th&gt;개념/역할&lt;/th&gt;
          &lt;th&gt;설명·예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Factory Method&lt;/td&gt;
          &lt;td&gt;객체 생성 추상화&lt;/td&gt;
          &lt;td&gt;Creator/Factory가 Product 생성 위임&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Abstract Factory&lt;/td&gt;
          &lt;td&gt;객체 집합 생성 팩터리&lt;/td&gt;
          &lt;td&gt;테마별/계열별 제품군 생성, 의존성 교체 용이&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Adapter&lt;/td&gt;
          &lt;td&gt;인터페이스 변환, 호환성 유지&lt;/td&gt;
          &lt;td&gt;구버전 → 신버전 연결&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Proxy&lt;/td&gt;
          &lt;td&gt;대리자 역할, 접근 제어&lt;/td&gt;
          &lt;td&gt;Spring AOP, Lazy Loading&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Composite&lt;/td&gt;
          &lt;td&gt;트리 구조, 전체-부분 계층&lt;/td&gt;
          &lt;td&gt;폴더-파일 구조, UI 구성&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Command&lt;/td&gt;
          &lt;td&gt;요청 캡슐화&lt;/td&gt;
          &lt;td&gt;실행/취소/이력 관리, Runnable, ActionListener&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Observer&lt;/td&gt;
          &lt;td&gt;이벤트 알림&lt;/td&gt;
          &lt;td&gt;MVC 패턴, 이벤트 구독자&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;State&lt;/td&gt;
          &lt;td&gt;상태에 따라 행위 변경&lt;/td&gt;
          &lt;td&gt;TCP 연결 상태, 게임 캐릭터 상태 등&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;자료구조&#34;&gt;자료구조
&lt;/h1&gt;&lt;h2 id=&#34;개념&#34;&gt;개념
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;동일 타입 데이터를 일정 구조로 저장&lt;/li&gt;
&lt;li&gt;탐색·삽입·삭제 등 연산 효율 극대화&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;주요-종류&#34;&gt;주요 종류
&lt;/h2&gt;&lt;h3 id=&#34;1-리스트와-배열&#34;&gt;1. 리스트와 배열
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;선형 저장, 탐색 O(n), 삽입/삭제 O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-스택과-큐&#34;&gt;2. 스택과 큐
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;스택: LIFO&lt;/li&gt;
&lt;li&gt;큐: FIFO&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-트리&#34;&gt;3. 트리
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;이진 트리 순회: 전위(NLR), 중위(LNR), 후위(LRN), 레벨 순회&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;스레드 이진 트리&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NULL 포인터 → 중위 순회 이웃 노드 연결&lt;/li&gt;
&lt;li&gt;재귀/스택 없이 반복문 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-서로소-집합&#34;&gt;4. 서로소 집합
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;find(x)&lt;/code&gt;: 대표 원소 탐색(경로 압축)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;union(x,y)&lt;/code&gt;: 두 집합 합치기(랭크 병합)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-해시-테이블&#34;&gt;5. 해시 테이블
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;해싱: 키 → 인덱스&lt;/li&gt;
&lt;li&gt;충돌 해결
&lt;ul&gt;
&lt;li&gt;개방 주소법(선형, 이차, 랜덤, 이중 해싱)&lt;/li&gt;
&lt;li&gt;체이닝(리스트, 트리 연결)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-우선순위-큐&#34;&gt;6. 우선순위 큐
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;높은 우선순위 데이터 먼저 처리&lt;/li&gt;
&lt;li&gt;보통 힙(Binary Heap)으로 구현&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-정렬&#34;&gt;7. 정렬
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;삽입·선택·퀵·병합 등&lt;/li&gt;
&lt;li&gt;데이터 특성과 조건에 맞게 선택&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>[커널아카데미] 백엔드 개발 부트캠프 13기 7주차</title>
        <link>http://localhost:1313/posts/week7-retrospective/</link>
        <pubDate>Sun, 03 Aug 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/week7-retrospective/</guid>
        <description>&lt;h2 id=&#34;이번-주-키워드&#34;&gt;이번 주 키워드
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;데이터 모델링&lt;/li&gt;
&lt;li&gt;SQL 튜닝 및 인덱스 최적화&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;데이터-모델링-이론&#34;&gt;데이터 모델링 이론
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;모델(Model)&lt;/strong&gt;: 실제(업무)를 추상화해 만든 가상 구조.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;모델링(Modeling)&lt;/strong&gt;: 현실(비즈니스) 분석 → 데이터로 표현할 수 있도록 구조화.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;목적&lt;/strong&gt;: 실제 업무를 효율적으로 시스템에 반영·지원하기 위함.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;모델링 단계&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;개념 모델&lt;/strong&gt;: 핵심 엔티티·주제영역 도출, 전체 구조 파악 (AS-IS/TO-BE)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;논리 모델&lt;/strong&gt;: 명확하고 구체적인 규칙·관계/제약 설정 (정규화)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;물리 모델&lt;/strong&gt;: 실제 DB에 적합한 구조(컬럼타입/파티션/인덱스) 설계&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;데이터-모델의-주요-용어&#34;&gt;데이터 모델의 주요 용어
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;용어&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;엔티티&lt;/td&gt;
          &lt;td&gt;관리 대상이 되는 데이터 집합 (예: 고객, 주문)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;속성&lt;/td&gt;
          &lt;td&gt;엔티티의 구체적 성질(예: 이름, 이메일)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;식별자&lt;/td&gt;
          &lt;td&gt;유일하게 엔티티 구분 (Primary Key)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;도메인&lt;/td&gt;
          &lt;td&gt;속성의 데이터 타입 및 허용값 범위&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;관계&lt;/td&gt;
          &lt;td&gt;엔티티 간 연결 (1:1, 1:N, M:N 등)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;ERD&lt;/td&gt;
          &lt;td&gt;엔티티 관계를 시각적으로 표현 (ER 다이어그램)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;일반화/특수화&lt;/strong&gt;: 상하위 엔티티 추상화(클래스 상속 비슷)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;자기참조/재귀관계&lt;/strong&gt;: 엔티티가 자기 자신과 관계를 가질 때 (예: 사원-상사)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;관계형-데이터-모델&#34;&gt;관계형 데이터 모델
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;스키마&lt;/strong&gt;: 테이블 구조(릴레이션명+컬럼명 등)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;튜플&lt;/strong&gt;: 테이블의 한 행(데이터 한 건)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;제약조건&#34;&gt;제약조건
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;키 제약조건&lt;/strong&gt;: Primary Key, Unique 등&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;실체 무결성&lt;/strong&gt;: PK는 Null 불가&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;영역 무결성(Domain Integrity)&lt;/strong&gt;: 지정한 도메인 범위 값만 허용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;함수-종속함수적-종속성&#34;&gt;함수 종속(함수적 종속성)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;어떤 칼럼 값이 결정되면 나머지가 정해지는 관계(예: 학번 → 이름)&lt;/li&gt;
&lt;li&gt;완전/부분/이행적 함수 종속; 완전 함수 종속만 남도록 테이블을 쪼개는 것 = 정규화&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;데이터-모델링-실습&#34;&gt;데이터 모델링 실습
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;개념 모델링&lt;/strong&gt;: 업무 분석 → 주제영역·핵심 엔티티 도출, 엔티티 관계 설계&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;논리 모델링&lt;/strong&gt;: 엔티티/속성/관계 상세화, 도메인·제약조건 명확히 정의&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;물리 모델링&lt;/strong&gt;: 실제 DB에 맞게 타입/인덱스/파티션 설계&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;엔티티 명명&lt;/strong&gt;: 전체에서 유일하게, 쉽게 이해되는 이름&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;식별자 설계&lt;/strong&gt;: 유일하고 불변, 최소구성, Not Null(본질/인조 식별자)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;표준화-및-모델-품질-관리&#34;&gt;표준화 및 모델 품질 관리
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;데이터 항목·도메인·코드 표준화(만들어진 도메인 사전 활용)&lt;/li&gt;
&lt;li&gt;코드(공통 코드, 테이블별 관리) 표준화&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sql-튜닝&#34;&gt;SQL 튜닝
&lt;/h2&gt;&lt;h3 id=&#34;sql-처리과정&#34;&gt;SQL 처리과정
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;사용자가 SQL 실행 → 옵티마이저가 실행계획 수립&lt;/li&gt;
&lt;li&gt;SQL 캐싱(SGA: 공유메모리, 라이브러리 캐시)
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;소프트 파싱&lt;/strong&gt;: 캐시에 동일 SQL 있으면 바로 실행&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;하드 파싱&lt;/strong&gt;: 없으면 파싱부터 재실행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PreparedStatement&lt;/strong&gt;: 파싱·실행분리, 캐시 활용/성능↑, 보안↑&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;데이터-저장-및-io-구조&#34;&gt;데이터 저장 및 I/O 구조
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;클러스터 팩터(Clustering Factor)&lt;/strong&gt;: 인덱스-테이블 레코드 간 물리적 근접도, 낮을수록 효율↑&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;블록(Block)&lt;/strong&gt;: 최소 I/O 단위(8KB 등)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;순차/랜덤 액세스&lt;/strong&gt;: 대량조회(순차/풀스캔), 소량조회(랜덤/인덱스스캔)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;논리적/물리적 I/O&lt;/strong&gt;: 캐시에서 읽거나 디스크 직접읽기&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인덱스-튜닝&#34;&gt;인덱스 튜닝
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;인덱스는 소량 데이터/조건절 자주 조회시 효율↑&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;DML(Insert/Update/Delete)이 많으면 인덱스가 오히려 성능↓, 디스크 낭비&lt;/li&gt;
&lt;li&gt;인덱스 스캔 방식: Range/Full/Unique/Skip Scan(조건/인덱스 특성에 따라)&lt;/li&gt;
&lt;li&gt;컬럼 변형, OR/IN/NULL, 부정조건에서는 인덱스가 잘 안 쓰일 수 있음&lt;/li&gt;
&lt;li&gt;인덱스 생성시 주요 컬럼·조건 부여 순서 고려&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;조인-및-서브쿼리소트-튜닝&#34;&gt;조인 및 서브쿼리/소트 튜닝
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;반정규화&lt;/strong&gt;: 조인비용 줄이는 대신 중복 허용&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;조인 방식&lt;/strong&gt;: NL(소량, 인덱스), 소트머지(정렬), 해시(대량/일회성)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서브쿼리 튜닝&lt;/strong&gt;: 인라인뷰/중첩/스칼라 서브쿼리, Exists/Unnest/Pushing/캐싱 활용&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;소트튜닝&lt;/strong&gt;: 메모리 소트 권장
&lt;ul&gt;
&lt;li&gt;Sort 오퍼레이션: Aggregate, Order By, Group By, Unique, Join, Window 등&lt;/li&gt;
&lt;li&gt;되도록 소트 지양, 반드시 필요하면 Union All·Exists 적극 활용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;마무리&#34;&gt;마무리
&lt;/h4&gt;&lt;p&gt;실제 실무에서는 데이터베이스 설계가 다양한 측면에서 중요하다는 사실을 깊이 깨닫게 됐다.&lt;br&gt;
그동안 프로젝트를 하면서는 종종 빠르게 결과를 내려고 DB 구조 설계 단계를 대충 넘겼지만,&lt;br&gt;
이번에 모델링 이론과 튜닝 원리까지 제대로 익히고 나니, 기초적인 이해 위에 세워진 체계적이고 탄탄한 DB 설계야말로&lt;br&gt;
생산성과 유지보수를 효율적으로 하는 데 도움이 되고, 좋은 서비스를 만드는 핵심이 된다는 것을 분명히 실감할 수 있었다.&lt;/p&gt;
&lt;p&gt;실제로 데이터를 어떻게 저장하고, 어떤 관계로 연결하며, 미래의 확장성이나 성능까지 고려하는 설계가 초기에 이뤄져야만,&lt;br&gt;
개발이 순조롭고 나중에 발생할 수 있는 성능 저하나 장애도 미리 예방할 수 있을 것 같다.&lt;br&gt;
데이터 모델링과 설계의 중요성을 마음에 새기고, 튼튼하게 설계 기반을 다질 수 있도록 노력해야겠다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[커널아카데미] 백엔드 개발 부트캠프 13기 6주차</title>
        <link>http://localhost:1313/posts/week6-retrospective/</link>
        <pubDate>Sun, 27 Jul 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/week6-retrospective/</guid>
        <description>&lt;h2 id=&#34;이번-주-키워드&#34;&gt;이번 주 키워드
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SQL 기초&lt;/li&gt;
&lt;li&gt;함수와 서브쿼리&lt;/li&gt;
&lt;li&gt;JOIN, PIVOT, RANK&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sql-기초&#34;&gt;SQL 기초
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SQL은 DB 서버에게 명령을 내리는 질의 언어&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SQL*PLUS&lt;/strong&gt;: Oracle에서 SQL/PLSQL 실행 환경 제공&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PL/SQL&lt;/strong&gt;: Oracle의 절차형 확장 언어(프로그램 로직 추가)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;테이블의 구성요소&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PK(Primary Key)&lt;/strong&gt;: Not Null + Unique, 테이블의 유일성 보장&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FK(Foreign Key)&lt;/strong&gt;: 다른 테이블 PK를 참조, 무결성 유지&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;INDEX&lt;/strong&gt;: 검색 속도 향상, 인덱스 사용 시 O(log n)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dml-data-manipulation-language&#34;&gt;DML (Data Manipulation Language)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;INSERT&lt;/strong&gt;: 한 행 입력&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UPDATE / DELETE&lt;/strong&gt;: 한 번에 1~여러 행 데이터 수정/삭제 가능&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SELECT&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;산술식, computed column(연산 컬럼)&lt;/li&gt;
&lt;li&gt;칼럼 연결: &lt;code&gt;name || &#39; &#39; || title as &amp;quot;직원명&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;중복 제거: &lt;code&gt;SELECT DISTINCT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;WHERE 절: 범위/조건 지정, IN/LIKE/%, _ 등 패턴매칭
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;: 0개 이상 문자, &lt;code&gt;_&lt;/code&gt;: 1개 문자&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;함수-function&#34;&gt;함수 (Function)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;문자형 함수&lt;/strong&gt;: UPPER, LOWER, INITCAP, CONCAT, SUBSTR, LENGTH, LPAD/RPAD, LTRIM/RTRIM, TRANSLATE, REPLACE&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;숫자형 함수&lt;/strong&gt;: ROUND, TRUNC, MOD, POWER, SQRT, SIGN, CHR&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;날짜형 함수&lt;/strong&gt;: SYSDATE, LAST_DAY, MONTHS_BETWEEN, ADD_MONTHS, ROUND/TRUNC 날짜 단위&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;변환 함수&lt;/strong&gt;: TO_CHAR, TO_NUMBER, TO_DATE&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;집계(그룹) 함수&lt;/strong&gt;: COUNT, AVG, SUM, MIN, MAX, STDDEV, VARIANCE&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;group-by와-subgroup&#34;&gt;GROUP BY와 Subgroup
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;GROUP BY 시 SELECT에 그룹 함수, 그룹 컬럼만 허용&lt;/li&gt;
&lt;li&gt;WHERE → ROWNUM → ORDER BY 순서로 처리됨&lt;/li&gt;
&lt;li&gt;그룹 세분화 가능: GROUP BY 여러 조건 지정&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;join&#34;&gt;JOIN
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;EQUIJOIN&lt;/strong&gt;: 동등 조인 (PK=FK)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NON-EQUIJOIN&lt;/strong&gt;: 등급, 누적합 등 정확히 일치하지 않는 값끼리 조인&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OUTER JOIN&lt;/strong&gt;: 매칭되지 않아도 표시 (부서 없는 직원 등)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SELF JOIN&lt;/strong&gt;: 테이블 자체를 서로 연결(상사-사원)&lt;/li&gt;
&lt;li&gt;집합 연산: UNION, UNION ALL, INTERSECT, MINUS&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;subquery-서브쿼리&#34;&gt;SubQuery (서브쿼리)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;쿼리 내부의 쿼리: 서브쿼리 → 메인쿼리 순으로 실행&lt;/li&gt;
&lt;li&gt;WHERE, HAVING, 컬럼 등에 활용
&lt;ul&gt;
&lt;li&gt;단일 행/다중 행 비교 연산자 (=, IN, ANY, ALL, EXISTS 등)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인라인 뷰&lt;/strong&gt;: FROM절에 서브쿼리 사용으로 효율적 검색&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;제약조건-constraint&#34;&gt;제약조건 (Constraint)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;컬럼 레벨 / 테이블 레벨&lt;/strong&gt; 모두 선언 가능&lt;/li&gt;
&lt;li&gt;NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK&lt;/li&gt;
&lt;li&gt;데이터의 무결성을 각 단계(입력, 수정, 삭제)에서 보장&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;트랜잭션과-딕셔너리&#34;&gt;트랜잭션과 딕셔너리
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;트랜잭션&lt;/strong&gt;: SQL 문장 묶음, COMMIT/ROLLBACK&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;딕셔너리(데이터 사전)&lt;/strong&gt;: USER* / ALL* / DBA_ 등의 메타정보, V$(성능·락 정보), DICTIONARY 뷰&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ddl-dcl&#34;&gt;DDL, DCL
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DDL (Data Definition Language)&lt;/strong&gt;: 테이블 등 구조 생성·변경, 자동 커밋, 롤백 불가&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DCL (Data Control Language)&lt;/strong&gt;: 권한(ROLE) 부여/회수 - GRANT, REVOKE&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;객체object&#34;&gt;객체(Object)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;시퀀스(Sequence)&lt;/strong&gt;: 자동 번호(Unique Number) 발생, 여러 객체에서 공유 가능
&lt;ul&gt;
&lt;li&gt;START WITH, NEXTVAL, CURRVAL&lt;/li&gt;
&lt;li&gt;생성 후 ALTER로 일부 속성만 변경 가능, 값은 자동 유효성 검사&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인덱스(Index)&lt;/strong&gt;: B*Tree 기반, PK/UNIQUE는 Unique Index 자동 생성
&lt;ul&gt;
&lt;li&gt;데이터 적고 조회 비율 높으면 효과적(10~15% 이하)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;뷰(View)&lt;/strong&gt;: 복잡한 쿼리 결과를 간단히 재활용, 보안 및 접근 제한&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시노님(Synonym)&lt;/strong&gt;: 다른 오브젝트에 별명 부여&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;프로그램 유닛&lt;/strong&gt;: 프로시저, 함수, 트리거, 패키지 등&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;고급-sql-기능&#34;&gt;고급 SQL 기능
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NVL&lt;/strong&gt;: NULL → 다른 값 치환&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DECODE&lt;/strong&gt;: IF/ELSE처럼 조건에 따라 값 반환&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CASE&lt;/strong&gt;: 복잡한 조건 처리 가능&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PIVOT&lt;/strong&gt;: 행→열 전환(피벗 테이블 작성)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ROLLUP/CUBE&lt;/strong&gt;: 그룹별 합계(소계) 계산&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RANK&lt;/strong&gt;: 행별(그룹별) 순위&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;의사컬럼(Pseudo Column)&lt;/strong&gt;: ROWNUM(순번), ROWID(물리주소), 인덱스 사용 여부 등&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;트리거trigger&#34;&gt;트리거(Trigger)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;테이블에 특정한 DML(INSERT/UPDATE/DELETE) 명령이 발생시 자동 실행&lt;/li&gt;
&lt;li&gt;타이밍(BEFORE/AFTER), 범위(STATEMENT/ROW)로 구분&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;옵티마이저&#34;&gt;옵티마이저
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SQL을 가장 효율적으로 실행하도록 실행계획(컴파일) 결정&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;마무리&#34;&gt;마무리
&lt;/h4&gt;&lt;p&gt;이번 주 학습을 통해 DDL, DML 등 자주 사용하는 SQL 문법에만 익숙해진 나머지,&lt;br&gt;
실제로는 다양한 DB 개념들을 많이 잊고 있었다는 점을 다시 한 번 실감했다.&lt;br&gt;
프로젝트나 실무에서 데이터 조작과 테이블 구조 관리에만 신경 쓰다 보면,&lt;br&gt;
DB 설계나 튜닝에 있어서 정말 중요한 핵심 원리들이 뒷전으로 밀려나는 경우가 많은 것 같다.&lt;/p&gt;
&lt;p&gt;특히 좋은 DB 설계와 효율적인 성능 튜닝을 위해서는 단지 SQL 쿼리문만 잘 쓰는 것에서 한 걸음 더 나아가,&lt;br&gt;
제약조건이나 인덱스 구조, 트랜잭션 처리, 뷰·시퀀스 같은 객체의 특성과 역할을 확실히 이해하고 있어야 함을 느꼈다.&lt;br&gt;
이번 기회를 통해 오래된 개념들도 제대로 복습하고, 단편적인 쿼리 작성 실력만 키우는 게 아니라&lt;br&gt;
실무에 바로 적용 가능한 탄탄한 DB 설계 능력까지 함께 키워야겠다고 다짐했다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[커널아카데미] 백엔드 개발 부트캠프 13기 5주차</title>
        <link>http://localhost:1313/posts/week5-retrospective/</link>
        <pubDate>Sun, 20 Jul 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/week5-retrospective/</guid>
        <description>&lt;div style=&#34;margin: 0 40px;&#34;&gt;
&lt;h2 id=&#34;이번-주-키워드&#34;&gt;이번 주 키워드
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;쓰레드(Thread)&lt;/li&gt;
&lt;li&gt;람다&lt;/li&gt;
&lt;li&gt;스트림&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;쓰레드thread&#34;&gt;쓰레드(Thread)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;프로세스(Process)&lt;/strong&gt;: 실행 중인 프로그램&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;쓰레드(Thread)&lt;/strong&gt;: 프로세스 내에서 실제 작업을 수행하는 최소 단위&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;멀티쓰레딩&lt;/strong&gt;: 하나의 프로세스에서 여러 쓰레드가 병렬로 작업, 효율성과 응답성 향상&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;멀티쓰레딩의-장점과-단점&#34;&gt;멀티쓰레딩의 장점과 단점
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CPU 사용률 증가&lt;/li&gt;
&lt;li&gt;자원 활용 효율적&lt;/li&gt;
&lt;li&gt;사용자 응답성 증가&lt;/li&gt;
&lt;li&gt;코드 모듈화, 관리 용이&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;자원 공유 시 동기화 문제&lt;/li&gt;
&lt;li&gt;교착상태(Deadlock) 위험&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;교착상태: 여러 쓰레드가 서로 필요한 자원을 점유하며 서로 대기, 작업이 중단된 상태&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;쓰레드-구현-방식&#34;&gt;쓰레드 구현 방식
&lt;/h2&gt;&lt;h3 id=&#34;1-thread-클래스-상속-template-method-pattern&#34;&gt;1. Thread 클래스 상속 (Template Method Pattern)
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyThread&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Thread {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(getName());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MyThread myThread &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MyThread();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;단점: 다른 클래스 상속 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-runnable-인터페이스-구현-strategy-pattern&#34;&gt;2. Runnable 인터페이스 구현 (Strategy Pattern)
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyRunnable&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; Runnable {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;currentThread&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;getName&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Runnable r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MyRunnable();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Thread t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(r);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;장점: 코드 재사용성, 일관성 우수&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;쓰레드-실행&#34;&gt;쓰레드 실행
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;반드시 &lt;code&gt;start()&lt;/code&gt; 호출 → 새로운 쓰레드 생성&lt;/li&gt;
&lt;li&gt;&lt;code&gt;run()&lt;/code&gt;만 호출 시 일반 메서드 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;쓰레드-실행-제어&#34;&gt;쓰레드 실행 제어
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;메서드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;sleep(long ms)&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;지정 시간만큼 쓰레드 일시정지&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;지정 쓰레드 작업 완료까지 대기&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;interrupt()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;일시정지 중인 쓰레드를 깨움&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;yield()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;CPU를 다른 동등 우선순위 쓰레드에게 양보&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;resume()&lt;/code&gt;, &lt;code&gt;suspend()&lt;/code&gt;, &lt;code&gt;stop()&lt;/code&gt;은 데드락 등 안전 이슈로 사용 불가(Deprecated)[3][5].&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;쓰레드-상태&#34;&gt;쓰레드 상태
&lt;/h3&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;상태&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;NEW&lt;/td&gt;
          &lt;td&gt;쓰레드 생성, 아직 &lt;code&gt;start()&lt;/code&gt; 호출 전&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RUNNABLE&lt;/td&gt;
          &lt;td&gt;실행 중 혹은 실행 대기&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;BLOCKED&lt;/td&gt;
          &lt;td&gt;락 획득 대기 중&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;WAITING&lt;/td&gt;
          &lt;td&gt;무한 대기&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;TIMED_WAITING&lt;/td&gt;
          &lt;td&gt;지정된 시간 대기&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;TERMINATED&lt;/td&gt;
          &lt;td&gt;실행 종료&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;쓰레드의-동기화&#34;&gt;쓰레드의 동기화
&lt;/h2&gt;&lt;p&gt;멀티쓰레드 환경에서 &lt;strong&gt;공유 자원&lt;/strong&gt; 접근 시 데이터 일관성을 보장하기 위해 동기화 필요&lt;/p&gt;
&lt;h3 id=&#34;임계-영역--락lock&#34;&gt;임계 영역 &amp;amp; 락(Lock)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;임계 영역&lt;/strong&gt;: 동시에 하나의 쓰레드만 실행할 수 있는 코드 영역&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lock&lt;/strong&gt;: 객체에 대한 접근을 제한하여 데이터 일관성 보장&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;synchronized&#34;&gt;synchronized
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;메서드 전체 동기화&lt;/strong&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;() { ... }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;블록 동기화&lt;/strong&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt;(참조변수) { ... }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;객체별로 하나의 Lock 보유&lt;/li&gt;
&lt;li&gt;가능한 한 임계 영역 최소화 (블록 단위)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;wait--notify&#34;&gt;wait() / notify()
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;wait()&lt;/strong&gt;: 락을 반납하고 대기&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;notify()/notifyAll()&lt;/strong&gt;: 대기 중인 쓰레드 깨움&lt;/li&gt;
&lt;li&gt;Object 메서드이므로 동기화 블록/메서드 내에서만 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;명시적-lock과-condition&#34;&gt;명시적 Lock과 Condition
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lock 클래스&lt;/strong&gt;: java.util.concurrent.locks
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;, &lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;, &lt;code&gt;StampedLock&lt;/code&gt; 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;조건 변수(Condition)&lt;/strong&gt;: 선별적인 알림, 기아(starvation) 해소&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lock.&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 임계 영역&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    lock.&lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;락은 수동 해제 필요(&lt;code&gt;finally&lt;/code&gt;로 처리)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;volatile&#34;&gt;volatile
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;변수의 값을 각 쓰레드 캐시에 저장하지 않고 &lt;strong&gt;항상 메모리에서 읽음&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;변수의 원자성만 보장, 동기화 대용 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;fork--join-프레임워크&#34;&gt;fork &amp;amp; join 프레임워크
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JDK7 도입, 작업을 작은 단위로 나눠 병렬 수행&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RecursiveAction&lt;/code&gt;: 반환값 없음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RecursiveTask&lt;/code&gt;: 반환값 있음&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;작업 분할&lt;/strong&gt; → &lt;strong&gt;work stealing&lt;/strong&gt; (작업 훔치기)로 부하 분산&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;가상-쓰레드virtual-thread&#34;&gt;가상 쓰레드(Virtual Thread)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;적은 자원으로 &lt;strong&gt;수십~수천만 개&lt;/strong&gt; 생성 가능&lt;/li&gt;
&lt;li&gt;항상 &lt;strong&gt;데몬 쓰레드&lt;/strong&gt;, 우선순위 고정(5)&lt;/li&gt;
&lt;li&gt;ThreadLocal 사용 주의, 풀링 금지&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;구분&lt;/th&gt;
          &lt;th&gt;플랫폼 쓰레드&lt;/th&gt;
          &lt;th&gt;가상 쓰레드&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;스케줄러&lt;/td&gt;
          &lt;td&gt;OS&lt;/td&gt;
          &lt;td&gt;JDK&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;생성수&lt;/td&gt;
          &lt;td&gt;수십만 개&lt;/td&gt;
          &lt;td&gt;수천만 개&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;호출 스택&lt;/td&gt;
          &lt;td&gt;2MB (고정)&lt;/td&gt;
          &lt;td&gt;4KB 이상 (가변)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;생성 시간&lt;/td&gt;
          &lt;td&gt;40us&lt;/td&gt;
          &lt;td&gt;0.4us&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;컨텍스트 스위칭&lt;/td&gt;
          &lt;td&gt;10us&lt;/td&gt;
          &lt;td&gt;1us&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;컨티뉴에이션, 스택 청크&lt;/strong&gt; 기반으로 경량 동작&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;executor--executorservice&#34;&gt;Executor &amp;amp; ExecutorService
&lt;/h2&gt;&lt;h3 id=&#34;executor-패턴&#34;&gt;Executor 패턴
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;작업 실행 추상화&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;threadfactory&#34;&gt;ThreadFactory
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;생성과 실행 분리, 객체 재사용에 유리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;executorservice&#34;&gt;ExecutorService
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;다양한 쓰레드 풀 제공
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SingleThreadExecutor&lt;/strong&gt;: 하나의 쓰레드가 모든 작업 처리&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;newThreadPerTaskExecutor&lt;/strong&gt;: 작업마다 플랫폼 쓰레드 생성(재사용 X)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;newVirtualThreadPerTaskExecutor&lt;/strong&gt;: 작업마다 가상 쓰레드 생성(재사용 X)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;future&#34;&gt;Future
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;비동기 작업 결과 조회/통제 객체&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get()&lt;/code&gt;: 결과 반환(블록), &lt;code&gt;cancel()&lt;/code&gt;: 작업 취소&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;completablefuture&#34;&gt;CompletableFuture
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;여러 비동기 작업을 연결하거나 조합할 때 활용&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;람다와-스트림-함수형-프로그래밍-맛보기&#34;&gt;람다와 스트림 (함수형 프로그래밍 맛보기)
&lt;/h2&gt;&lt;h3 id=&#34;람다식&#34;&gt;람다식
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;익명 함수, 메서드를 간결히 표현&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(매개변수) -&amp;gt; {실행문}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;함수형-인터페이스&#34;&gt;함수형 인터페이스
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;추상 메서드 1개만 선언&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@FunctionalInterface&lt;/code&gt;로 컴파일러 안전성 확보&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@FunctionalInterface&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyFunction&lt;/span&gt;{ &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;myMethod&lt;/span&gt;(); }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;스트림stream&#34;&gt;스트림(Stream)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;데이터 소스&lt;/strong&gt;(컬렉션, 배열 등)를 복잡한 반복문 없이 다루는 방법&lt;/li&gt;
&lt;li&gt;연산은 대부분 &lt;strong&gt;파이프라인&lt;/strong&gt; 형태&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;스트림-특징&#34;&gt;스트림 특징
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;데이터 원본 불변&lt;/li&gt;
&lt;li&gt;일회성&lt;/li&gt;
&lt;li&gt;내부반복&lt;/li&gt;
&lt;li&gt;중간/최종 연산 분리&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;스트림-연산-종류&#34;&gt;스트림 연산 종류
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;중간 연산&lt;/strong&gt;: filter, map, sorted 등 (0~여러 번)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;최종 연산&lt;/strong&gt;: forEach, reduce, collect 등 (0~1번)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;collect-vs-reduce&#34;&gt;collect() vs reduce()
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;collect()&lt;/code&gt; : 그룹별 집계·추출(분할, 그룹화)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reduce()&lt;/code&gt; : 누적 합산&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;병렬-스트림&#34;&gt;병렬 스트림
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;여러 CPU 코어 사용, 요소 순서 보장 X&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;optional&#34;&gt;Optional
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;null 안전하게 다루기 위한 컨테이너&lt;/li&gt;
&lt;li&gt;null 반환 대신 Optional 객체 반환&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;참고사항:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;멀티쓰레딩/가상쓰레드 설계시 동기화·Deadlock 예방·디버깅 용이성 필수 고려&lt;/li&gt;
&lt;li&gt;비동기, 동시성 제어시 ExecutorService·CompletableFuture 활용&lt;/li&gt;
&lt;li&gt;함수형 코드 작성시 함수형 인터페이스와 람다 적극 활용&lt;/li&gt;
&lt;li&gt;대량 데이터 처리시 Stream과 Optional 적극 활용&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;마무리&#34;&gt;마무리
&lt;/h2&gt;&lt;p&gt;이번 주는 쓰레드, 동기화, 가상 쓰레드 같은 핵심 개념을 한 번에 완벽하게 이해하기가 쉽지 않았던 한 주였다.&lt;br&gt;
개념만 읽을 때는 헷갈리는 부분도 많았지만, 직접 다양한 예제 코드를 작성해보면서 조금씩 감을 잡아야겠다.&lt;/p&gt;
&lt;p&gt;또, 가상 쓰레드(virtual thread)나 ExecutorService, 람다와 스트림 같은 최신 트렌드까지 폭넓게 다루다 보니&lt;br&gt;
한 번에 다 흡수하긴 어렵다는 생각도 들었다.&lt;br&gt;
하지만 이런 내용이 최신 Java에서 왜 중요한지, 앞으로 개발하면서 어떻게 활용할 수 있을지 궁금해지는 계기가 되었다.&lt;/p&gt;
&lt;p&gt;앞으로는 각 개념별로 작은 예시를 직접 더 많이 만들어보고, 잘 정리해서 내 것으로 만들어야 할 것 같다.&lt;br&gt;
어렵고 멀게만 느껴졌던 동시성, 함수형 프로그래밍에도 점점 익숙해질 수 있도록 꾸준히 연습해야겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[커널아카데미] 백엔드 개발 부트캠프 13기 4주차</title>
        <link>http://localhost:1313/posts/week4-retrospective/</link>
        <pubDate>Fri, 11 Jul 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/week4-retrospective/</guid>
        <description>&lt;div style=&#34;margin: 0 40px;&#34;&gt;
&lt;h1 id=&#34;이번-주-키워드&#34;&gt;이번 주 키워드
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;컬렉션 프레임워크&lt;/li&gt;
&lt;li&gt;모던 자바 기능&lt;/li&gt;
&lt;li&gt;쓰레드&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-컬렉션-프레임워크&#34;&gt;1. 컬렉션 프레임워크
&lt;/h2&gt;&lt;p&gt;컬렉션: 여러 객체(데이터)를 모아 놓은 것&lt;br&gt;
프레임워크: 표준화, 정형화된 체계적인 프로그래밍 방식&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;핵심 인터페이스&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;List&lt;/strong&gt;: 순서 O, 중복 O&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set&lt;/strong&gt;: 순서 X, 중복 X&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Map&lt;/strong&gt;: key-value 구조, 순서 X, 키 중복 X, 값 중복 O&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;list&#34;&gt;List
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;중복 허용, 저장 순서 유지&lt;/li&gt;
&lt;li&gt;주요 메서드: &lt;code&gt;get(int index)&lt;/code&gt;, &lt;code&gt;remove(int index)&lt;/code&gt;, &lt;code&gt;set(int index, Object obj)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;저장 순서 유지, 중복 허용&lt;/li&gt;
&lt;li&gt;remove 시 요소 이동 및 size 감소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt;: 데이터 읽기 속도 빠름(O(1)), 구조 간단&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;: 크기 변경 불가, 비순차적 추가/삭제 느림&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;LinkedList&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;추가/삭제 빠름(연결만 변경)&lt;/li&gt;
&lt;li&gt;순서 O, 중복 허용, 조회는 O(n)&lt;/li&gt;
&lt;li&gt;단방향 → Double Linked List, Double Circular Linked List로 개선&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;결론&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;순차적 추가/삭제: ArrayList &amp;gt; LinkedList&lt;/li&gt;
&lt;li&gt;중간 데이터 추가/삭제: ArrayList LinkedList&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Stack &amp;amp; Queue&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Stack&lt;/strong&gt;: LIFO, 배열 적합, 객체 생성 가능&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Queue&lt;/strong&gt;: FIFO, LinkedList 적합, 구현체 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PriorityQueue&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;우선순위 높은 요소부터 꺼냄&lt;/li&gt;
&lt;li&gt;null 저장 불가, 내부적으로 힙 구조 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Deque&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;양쪽 끝에 추가/삭제 가능&lt;/li&gt;
&lt;li&gt;구현체: ArrayDeque, LinkedList 등&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;컬렉션-요소-접근&#34;&gt;컬렉션 요소 접근
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Iterator &amp;amp; Iterable&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Iterator&lt;/strong&gt;: 컬렉션 요소를 하나씩 접근&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Iterable&lt;/strong&gt;: Iterator 반환 메서드 정의&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Map은 keySet(), entrySet() 등으로 Set 형태로 변환 후 iterator 사용&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Enumeration&lt;/strong&gt;: Iterator의 구버전&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ListIterator&lt;/strong&gt;: 양방향, List 구현체만 사용 가능&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Arrays 유틸리티&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;메서드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;copyOf(), copyOfRange()&lt;/td&gt;
          &lt;td&gt;배열 복사&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;fill(), setAll()&lt;/td&gt;
          &lt;td&gt;배열 채우기&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;sort(), binarySearch()&lt;/td&gt;
          &lt;td&gt;배열 정렬/검색 (정렬 후 검색해야 정확)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;toString(), equals(), compare(), mismatch()&lt;/td&gt;
          &lt;td&gt;배열 출력/비교/정렬/불일치 인덱스 반환&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;asList()&lt;/td&gt;
          &lt;td&gt;배열을 List로 변환&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Comparator &amp;amp; Comparable&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Comparable&lt;/strong&gt;: 기본 정렬 기준(오름차순)
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public interface Comparable {
    int compareTo(T o);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Comparator&lt;/strong&gt;: 별도 정렬 기준 제공(내림차순 등)
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public interface Comparator {
    int compare(T o1, T o2);
    boolean equals(Object obj);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;set&#34;&gt;Set
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;HashSet&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중복 저장 불가, 저장 순서 없음&lt;/li&gt;
&lt;li&gt;필요시 LinkedHashSet 사용&lt;/li&gt;
&lt;li&gt;add() 시 hashCode(), equals()로 중복 판별&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TreeSet&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이진 탐색 트리 구조, 중복 불가, 순서 없음&lt;/li&gt;
&lt;li&gt;정렬/검색/범위검색에 성능 우수&lt;/li&gt;
&lt;li&gt;Comparable 구현 or Comparator 제공 필요&lt;/li&gt;
&lt;li&gt;In-Order 순회로 정렬 결과 얻음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;map&#34;&gt;Map
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;HashMap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(구버전: HashTable)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hashing 기법(배열+LinkedList 장점)&lt;/li&gt;
&lt;li&gt;저장 순서 없음(LinkedHashMap 필요시 사용)&lt;/li&gt;
&lt;li&gt;키는 유일, 값 중복 가능, null 허용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TreeMap&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이진 검색 트리 구조, 검색/정렬에 적합&lt;/li&gt;
&lt;li&gt;범위검색/정렬 필요시 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Properties&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String key-value 저장, Hashtable 상속&lt;/li&gt;
&lt;li&gt;저장 순서 없음, Enumeration 사용&lt;/li&gt;
&lt;li&gt;환경설정 파일 등에서 사용, 파일 입출력 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;collections-클래스&#34;&gt;Collections 클래스
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;동기화 컬렉션&lt;/strong&gt;: &lt;code&gt;Collections.synchronizedXXX()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;변경 불가 컬렉션&lt;/strong&gt;: &lt;code&gt;Collections.unmodifiableXXX()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;한 종류 객체만 저장&lt;/strong&gt;: &lt;code&gt;Collections.checkedXXX()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;싱글톤 컬렉션&lt;/strong&gt;: &lt;code&gt;Collections.singletonXXX()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;2-모던-자바-기능&#34;&gt;2. 모던 자바 기능
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;제너릭스 (Generics)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 타입의 객체를 다루는 메서드/컬렉션에서 컴파일 시 타입 체크&lt;/li&gt;
&lt;li&gt;타입 안정성, 형변환 생략 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;선언 및 사용법&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Box appleBox = new Box();
Box fruitBox = new Box();
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;static 멤버에는 타입 변수 사용 불가&lt;/li&gt;
&lt;li&gt;제너릭 배열 생성 불가(참조 변수 선언은 가능)&lt;/li&gt;
&lt;li&gt;JDK 7+에서는 생성자 타입 생략 가능: &lt;code&gt;new ArrayList&amp;lt;&amp;gt;()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;제한된 제너릭&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extends&lt;/code&gt;: 특정 타입의 자손만 허용&lt;/li&gt;
&lt;li&gt;인터페이스도 extends, 다중 제한은 &lt;code&gt;&amp;amp;&lt;/code&gt;로 구분&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;와일드카드&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;: 상한 제한(자손만 허용)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;: 하한 제한(조상만 허용)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;: 제한 없음, &lt;code&gt;&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 와 동일&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;제너릭 메서드&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메서드의 선언부에 제너릭 타입이 선언된 메서드&lt;/li&gt;
&lt;li&gt;반환타입 바로 앞에 선언&lt;/li&gt;
&lt;li&gt;제너릭 클래스가 아닌 클래스에도 정의 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;형변환과 타입 제거&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제너릭 ↔ 원시타입: 형변환 가능(경고 발생)&lt;/li&gt;
&lt;li&gt;제너릭 타입 간 형변환 불가&lt;/li&gt;
&lt;li&gt;컴파일 시 타입 체크 후 제너릭 정보 제거(타입 소거)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;열거형-enum&#34;&gt;열거형 (Enum)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;관련 상수를 편리하게 선언, 값 비교(&lt;code&gt;==&lt;/code&gt;)와 타입 체크 모두 가능&lt;/li&gt;
&lt;li&gt;객체 개수 제한(생성자 private)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;선언 및 사용법&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;enum Direction { EAST, SOUTH, WEST, NORTH }
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;비교: &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;compareTo()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;JDK 21+: switch문 조건식에 사용, 모든 case 처리 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;주요 메서드&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;메서드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;getDeclaringClass()&lt;/td&gt;
          &lt;td&gt;열거형의 Class 객체 반환&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;name()&lt;/td&gt;
          &lt;td&gt;상수 이름 반환&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;ordinal()&lt;/td&gt;
          &lt;td&gt;정의 순서(0부터) 반환&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;valueOf(Class, String)&lt;/td&gt;
          &lt;td&gt;이름으로 상수 반환&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;values()&lt;/td&gt;
          &lt;td&gt;모든 상수 배열 반환&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;멤버 추가&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;enum Direction {
    EAST(1), SOUTH(5), WEST(-1), NORTH(10);
    private final int value;
    Direction(int value) { this.value = value; }
    public int getValue() { return value; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;애너테이션-annotation&#34;&gt;애너테이션 (Annotation)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;프로그램에 메타데이터(부가 정보) 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;표준 애너테이션&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Override&lt;/code&gt;, &lt;code&gt;@SuppressWarnings&lt;/code&gt;, &lt;code&gt;@FunctionalInterface&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;메타 애너테이션&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Target&lt;/code&gt;, &lt;code&gt;@Retention&lt;/code&gt;, &lt;code&gt;@Native&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;record-레코드&#34;&gt;Record (레코드)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;불변 데이터 클래스를 간편하게 작성(JDK 16~)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;record Point(int x, int y) {}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;모든 레코드는 &lt;code&gt;java.lang.Record&lt;/code&gt; 상속(final, 다른 클래스 상속 불가)&lt;/li&gt;
&lt;li&gt;내부 변수/초기화 블럭 추가 불가, 내부 레코드는 항상 static&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;실드-클래스-sealed-class&#34;&gt;실드 클래스 (Sealed Class)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;상속 가능한 자식 클래스를 명시적으로 제한(JDK 17~)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sealed class Shape permits Circle, Rectangle {}
final class Circle extends Shape {}
non-sealed class Rectangle extends Shape {}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;자식은 final, sealed, non-sealed 중 하나여야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;모듈-시스템-module-system&#34;&gt;모듈 시스템 (Module System)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;패키지의 상위 집합, JDK 9+ 도입&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module-info.java&lt;/code&gt;로 모듈의 이름, 의존성, 공개 패키지 등 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;module org.example.myModule {
    requires java.desktop;
    exports org.example.pkgA;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;모듈 이름은 전역적으로 유일해야 함&lt;/li&gt;
&lt;li&gt;전이적 의존성(&lt;code&gt;requires transitive&lt;/code&gt;) 지원&lt;/li&gt;
&lt;li&gt;순환 의존성 금지&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;자동 모듈 &amp;amp; 이름 없는 모듈&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모듈 설명자 없는 jar → 자동 모듈&lt;/li&gt;
&lt;li&gt;이름 없는 모듈은 모든 모듈에 의존, 모든 패키지 노출&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;3-쓰레드&#34;&gt;3. 쓰레드
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;프로세스와 쓰레드&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;프로세스&lt;/strong&gt;: 실행 중인 프로그램(독립적 작업 단위)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;쓰레드&lt;/strong&gt;: 프로세스 내에서 실행되는 작업 흐름의 단위&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;구분&lt;/th&gt;
          &lt;th&gt;프로세스(Process)&lt;/th&gt;
          &lt;th&gt;쓰레드(Thread)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;정의&lt;/td&gt;
          &lt;td&gt;실행 중인 프로그램(독립적 작업 단위)&lt;/td&gt;
          &lt;td&gt;프로세스 내 실행 흐름(작업 단위)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;메모리&lt;/td&gt;
          &lt;td&gt;독립적(코드, 데이터, 힙, 스택 모두 별도)&lt;/td&gt;
          &lt;td&gt;코드/데이터/힙 공유, 스택만 독립&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;자원&lt;/td&gt;
          &lt;td&gt;자체 소유, 다른 프로세스와 공유 불가&lt;/td&gt;
          &lt;td&gt;같은 프로세스 내에서 자원 공유&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;통신&lt;/td&gt;
          &lt;td&gt;IPC 등 별도 방식 필요&lt;/td&gt;
          &lt;td&gt;간단(공유 변수 등)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;오버헤드&lt;/td&gt;
          &lt;td&gt;크고 무거움&lt;/td&gt;
          &lt;td&gt;가볍고 빠름&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;안정성&lt;/td&gt;
          &lt;td&gt;하나 종료돼도 다른 프로세스 영향 없음&lt;/td&gt;
          &lt;td&gt;하나 오류 시 전체 프로세스 영향 가능&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;멀티태스킹 vs 멀티쓰레딩&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;멀티태스킹&lt;/strong&gt;: 여러 프로세스가 동시에 실행&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;멀티쓰레딩&lt;/strong&gt;: 하나의 프로세스 내 여러 쓰레드가 동시에 작업 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 사용률 및 자원 효율성 향상&lt;/li&gt;
&lt;li&gt;사용자 응답성 향상&lt;/li&gt;
&lt;li&gt;코드 분리로 간결해짐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자원 공유로 인한 동기화, 교착상태(Deadlock) 등 문제 발생 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;쓰레드의-구현과-실행&#34;&gt;쓰레드의 구현과 실행
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;구현 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Thread 클래스 상속&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class MyThread extends Thread {
    public void run() {
        System.out.println(getName());
    }
}
MyThread t = new MyThread();
t.start();
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;단점: 다른 클래스 상속 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Runnable 인터페이스 구현&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class MyRunnable implements Runnable {
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
Thread t = new Thread(new MyRunnable());
t.start();
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;장점: 재사용성, 코드 일관성, 다른 클래스 상속 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;실행&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;반드시 &lt;code&gt;start()&lt;/code&gt; 호출 → 새로운 쓰레드가 생성되어 run() 실행&lt;/li&gt;
&lt;li&gt;한 번 종료된 쓰레드는 재실행 불가(새 객체 필요)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;start()와 run()의 차이&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;run()&lt;/code&gt;: 단순 메서드 호출(새 쓰레드 생성 X)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start()&lt;/code&gt;: 새로운 쓰레드 생성, 호출 스택 생성 후 run() 호출&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;실행 중인 사용자 쓰레드가 하나도 없으면 프로그램 종료&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;싱글쓰레드와 멀티쓰레드&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;싱글쓰레드&lt;/strong&gt;: 한 작업이 끝난 후 다른 작업 시작&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;멀티쓰레드&lt;/strong&gt;: 여러 작업을 번갈아가며 처리, 동시에 실행되는 것처럼 보임&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;병행(Concurrency) vs 병렬(Parallelism)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;병행&lt;/strong&gt;: 여러 쓰레드가 여러 작업을 동시에 진행&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;병렬&lt;/strong&gt;: 하나의 작업을 여러 쓰레드가 나눠서 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;쓰레드의 우선순위&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1~10 범위의 priority 멤버변수로 우선순위 지정&lt;/li&gt;
&lt;li&gt;높을수록 더 많은 작업 시간 할당&lt;/li&gt;
&lt;li&gt;시각적/응답성 작업은 우선순위 높게 설정&lt;/li&gt;
&lt;li&gt;우선순위는 부모 쓰레드로부터 상속&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;쓰레드 그룹&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;관련 쓰레드를 그룹으로 관리&lt;/li&gt;
&lt;li&gt;그룹 내 다른 그룹 포함 가능(계층 구조)&lt;/li&gt;
&lt;li&gt;모든 쓰레드는 반드시 쓰레드 그룹에 포함&lt;/li&gt;
&lt;li&gt;기본적으로 main 쓰레드 그룹의 하위 그룹&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;데몬 쓰레드&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;보조 작업(예: 가비지 컬렉터) 담당&lt;/li&gt;
&lt;li&gt;무한루프+조건문으로 대기하다가 작업 수행&lt;/li&gt;
&lt;li&gt;데몬 쓰레드가 생성한 쓰레드도 자동으로 데몬&lt;/li&gt;
&lt;li&gt;사용자 쓰레드가 모두 종료되면 데몬도 자동 종료&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;쓰레드 실행 제어&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;메서드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;static void sleep()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;지정 시간 동안 쓰레드 일시 정지&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;void join()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;지정 시간 동안 쓰레드가 실행되도록 함&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;interrupt()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;쓰레드 작업 취소(정지 요청, sleep/join 상태 깨움)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;static void yield()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;실행 시간 양보, 실행 대기 상태로 전환&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;resume(), stop(), suspend()는 데드락 위험으로 deprecated&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;쓰레드의 상태&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;상태&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;NEW&lt;/td&gt;
          &lt;td&gt;생성, start() 미호출&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RUNNABLE&lt;/td&gt;
          &lt;td&gt;실행 중 또는 실행 가능&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;BLOCKED&lt;/td&gt;
          &lt;td&gt;동기화 블록에 의해 일시 정지(lock 대기)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;WAITING&lt;/td&gt;
          &lt;td&gt;실행 가능하지 않은 일시 정지(조건 대기 등)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;TIMED_WAITING&lt;/td&gt;
          &lt;td&gt;지정 시간 동안 일시 정지&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;TERMINATED&lt;/td&gt;
          &lt;td&gt;작업 종료&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;h2 id=&#34;마무리&#34;&gt;마무리
&lt;/h2&gt;&lt;p&gt;낯선 개념들이 많아서 아직 정리가 덜 된 것 같지만&lt;br&gt;
한 번에 이해하려는 게 오히려 욕심인 거 같기도&amp;hellip;?&lt;/p&gt;
&lt;p&gt;익숙해질 때까지 자주 들여다봐야 할 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[커널아카데미] 백엔드 개발 부트캠프 13기 3주차</title>
        <link>http://localhost:1313/posts/week3-retrospective/</link>
        <pubDate>Fri, 04 Jul 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/week3-retrospective/</guid>
        <description>&lt;div style=&#34;margin: 0 40px;&#34;&gt;
&lt;h1 id=&#34;이번-주-키워드&#34;&gt;이번 주 키워드
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;예외 처리&lt;/strong&gt;, java.lang 패키지, 유용한 자바 클래스&lt;/p&gt;
&lt;h2 id=&#34;프로그램-오류와-예외&#34;&gt;프로그램 오류와 예외
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;프로그램 오류란?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;프로그램 실행 중 오작동을 하거나 비정상적으로 종료되게 하는 원인
발생 시점에 따라 아래와 같이 구분됨&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;컴파일 에러&lt;/strong&gt;: 코드 작성 중 컴파일러가 잡아내는 문법 오류&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;런타임 에러&lt;/strong&gt;: 실행 중 발생하는 오류 (예: 0으로 나누기, 배열 인덱스 초과)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;논리적 에러&lt;/strong&gt;: 실행은 되지만, 의도와 다르게 동작하는 오류&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;에러와 예외&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;에러(Error)&lt;/strong&gt;: 프로그램 코드로 수습할 수 없는 심각한 오류 (예: OutOfMemoryError)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예외(Exception)&lt;/strong&gt;: 코드로 수습 가능한 비교적 덜 심각한 오류&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;실행 중 발생하는 에러와 예외는 모두 &lt;code&gt;Throwable&lt;/code&gt;의 하위 클래스&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Throwable
 ├─ Error         // 시스템 오류, 복구 불가
 └─ Exception     // 예외 상황, 복구 가능
      ├─ RuntimeException (개발자 실수)
      └─ 기타 Exception (사용자 실수 등)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;예외-처리&#34;&gt;예외 처리
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;예외 처리란?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;프로그램 실행 중 발생할 수 있는 예기치 못한 예외에 대비한 코드를 작성하는 것
예외 발생으로 인한 프로그램의 갑작스런 종료를 막고 &lt;strong&gt;정상적인 실행 상태&lt;/strong&gt;를 유지하기 위함&lt;/p&gt;
&lt;p&gt;예외 처리의 기본은 &lt;strong&gt;로깅&lt;/strong&gt;
(에러가 발생했을 때 상태와 원인을 기록하여 추후 원인 분석 및 유지보수에 활용)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;예외 처리 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;try-catch&lt;/strong&gt;: 직접 예외를 처리&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;throws&lt;/strong&gt;: 예외를 호출자에게 전달&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예외 은폐&lt;/strong&gt;: 예외를 일부러 무시(권장하지 않음)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예외 되던지기(rethrow)&lt;/strong&gt;: catch에서 예외를 다시 던짐&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;try-catch 기본 구조&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 예외가 발생할 수 있는 코드&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (ExceptionType e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 예외 처리 코드&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 항상 실행되는 코드 (리소스 반환 등)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;
&lt;p&gt;&lt;strong&gt;예시&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Example&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 100;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 10; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)(Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;random&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; 10);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(result);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (ArithmeticException e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;
&lt;p&gt;&lt;strong&gt;multi-catch (Java 7+)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (IOException &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; SQLException e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    e.&lt;span style=&#34;color:#a6e22e&#34;&gt;printStackTrace&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;조상-자손 관계 예외는 묶을 수 없음&lt;/li&gt;
&lt;li&gt;멀티 catch 블록 내에서는 공통 조상 타입의 멤버만 사용 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;예외 발생시키기 (&lt;code&gt;throw&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;강제 예외 발생&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;
&lt;p&gt;&lt;strong&gt;예외의 종류&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Checked Exception&lt;/strong&gt;: 컴파일러가 예외 처리를 강제 (예: IOException)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unchecked Exception&lt;/strong&gt;: RuntimeException 및 그 자손, 컴파일러가 체크하지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;메서드에서 예외 선언 (&lt;code&gt;throws&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;readFile&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; IOException {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 파일 읽기 코드&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;
&lt;p&gt;&lt;strong&gt;finally 블록&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예외 발생 여부와 관계없이 항상 실행&lt;/li&gt;
&lt;li&gt;주로 리소스 반환, 파일 닫기 등에 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;try-with-resources (Java 7+)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; (BufferedReader br &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; BufferedReader(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileReader(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;file.txt&amp;#34;&lt;/span&gt;))) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 파일 읽기&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;(IOException e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    e.&lt;span style=&#34;color:#a6e22e&#34;&gt;printStackTrace&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;AutoCloseable 구현 객체는 자동으로 close() 호출&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;예외 되던지기(rethrow)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;catch 블록에서 예외를 다시 던져 호출자에게 전달&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;사용자 정의 예외&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exception을 상속받아 직접 정의 가능&lt;/li&gt;
&lt;li&gt;기존 예외로 충분하다면 가급적 표준 예외 사용 권장&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;예외 연결 (Chained Exception)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예외를 더 큰 단위로 묶어 처리 가능&lt;/li&gt;
&lt;li&gt;catch 블록을 단순화할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;javalang-패키지-주요-클래스&#34;&gt;java.lang 패키지 주요 클래스
&lt;/h2&gt;&lt;h3 id=&#34;object-클래스&#34;&gt;Object 클래스
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;모든 자바 클래스의 최상위 조상&lt;/li&gt;
&lt;li&gt;주요 메서드:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;equals(Object obj)&lt;/code&gt;: 객체 내용 비교 (오버라이딩 가능)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hashCode()&lt;/code&gt;: 해시코드 반환, 컬렉션에서 사용&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clone()&lt;/code&gt;: 객체 복제 (Cloneable 구현 필요)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getClass()&lt;/code&gt;: 클래스 정보 반환&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;string-클래스&#34;&gt;String 클래스
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Immutable&lt;/strong&gt;: 한 번 생성되면 변경 불가&lt;/li&gt;
&lt;li&gt;문자열 리터럴은 상수 풀에서 관리되어 같은 문자열은 같은 객체 참조&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;주요 메서드/특징&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;trim()&lt;/code&gt;: 아스키 공백만 제거&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strip()&lt;/code&gt;: 유니코드 공백도 제거&lt;/li&gt;
&lt;li&gt;&lt;code&gt;join()&lt;/code&gt;, &lt;code&gt;StringJoiner&lt;/code&gt;: 구분자를 넣어 문자열 결합&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getBytes(String charsetName)&lt;/code&gt;: 인코딩 변환&lt;/li&gt;
&lt;li&gt;&lt;code&gt;format()&lt;/code&gt;, &lt;code&gt;formatted()&lt;/code&gt;: 형식화된 문자열 생성&lt;/li&gt;
&lt;li&gt;&lt;code&gt;valueOf()&lt;/code&gt;: 기본형 → String 변환&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parse자료형()&lt;/code&gt;: String → 기본형 변환&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;StringBuffer와 StringBuilder&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;StringBuffer&lt;/strong&gt;: 스레드 안전, 동기화 지원&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;StringBuilder&lt;/strong&gt;: 동기화 미지원, 더 빠름&lt;/li&gt;
&lt;li&gt;equals() 오버라이딩 X → 내용 비교시 String으로 변환 후 비교&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;math-클래스&#34;&gt;Math 클래스
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;산술 연산 보조 메서드 제공 (&lt;code&gt;addExact&lt;/code&gt;, &lt;code&gt;subtractExact&lt;/code&gt; 등)&lt;/li&gt;
&lt;li&gt;오버플로우 체크 가능&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;StrictMath&lt;/strong&gt;: 플랫폼에 상관없이 일관된 결과 보장&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;래퍼wrapper-클래스&#34;&gt;래퍼(Wrapper) 클래스
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;기본형 값을 객체로 다룰 때 사용 (&lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt; 등)&lt;/li&gt;
&lt;li&gt;오토박싱/언박싱 지원&lt;/li&gt;
&lt;li&gt;-128~127 범위는 캐시로 재사용&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;javautil-주요-클래스&#34;&gt;java.util 주요 클래스
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;클래스&lt;/th&gt;
          &lt;th&gt;용도&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;Objects&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;null 체크, 객체 비교 등 유틸리티 메서드 제공&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;난수 생성, seed 지정 가능&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;regex&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;정규 표현식 지원, 텍스트 검색 및 치환&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;Scanner&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;콘솔/파일 입력을 편리하게 받을 때 사용&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;StringTokenizer&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;문자열을 여러 구분자로 토큰화 (split과 차이)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;매우 큰 정수 연산 지원&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;고정소수점 연산, 금융 계산 등 정밀한 소수점 연산에 사용&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;h2 id=&#34;날짜와-시간&#34;&gt;날짜와 시간
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java 8 이전&lt;/strong&gt;: &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;Calendar&lt;/code&gt; 클래스 사용 (불변 객체 아님, 복잡함)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java 8 이후&lt;/strong&gt;: &lt;code&gt;java.time&lt;/code&gt; 패키지 도입
&lt;ul&gt;
&lt;li&gt;불변 객체, 명확한 API 제공&lt;/li&gt;
&lt;li&gt;날짜, 시간, 기간, 포맷팅, 파싱 등 다양한 기능 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;날짜/시간 계산의 기본&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;시분초 → 초로 변환, 계산 후 다시 시분초로 변환&lt;/li&gt;
&lt;li&gt;년월일 → 일로 변환, 계산 후 다시 년월일로 변환&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;h2 id=&#34;마무리&#34;&gt;마무리
&lt;/h2&gt;&lt;p&gt;이번 주에는 자바의 예외 처리와 java.lang, java.util 패키지의 주요 클래스를 집중적으로 학습했다.&lt;/p&gt;
&lt;p&gt;프로젝트를 진행할 때마다 시간에 쫓겨 예외 처리나 테스트 코드 작성에 소홀했던 경험이 많았는데,&lt;br&gt;
실무에서는 로깅과 예외 처리, 그리고 테스트 코드의 중요성을 다시 한 번 깨달았다.&lt;/p&gt;
&lt;p&gt;실제로 전 직장에서 개발팀에 로그를 요청해 업무에 활용한 경험이 있었고,&lt;br&gt;
이 과정에서 로그가 안정적이고 유지보수하기 쉬운 코드를 작성하는 데 큰 도움이 될 뿐만 아니라,&lt;br&gt;
서비스 운영 중 발생하는 문제를 신속하게 해결하는 데도 매우 유용하다는 점을 체감했다.&lt;br&gt;
이러한 경험을 바탕으로 앞으로는 기능 구현뿐만 아니라 예외 처리와 테스트 코드 작성에도 더욱 신경 써야겠다고 다짐했다.&lt;/p&gt;
&lt;p&gt;앞으로는 꼼꼼하게 예외 처리와 테스트 코드를 챙기는 습관을 들여&lt;br&gt;
더 신뢰받는 개발자가 되고자 한다.
&lt;br&gt;&lt;br&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[커널아카데미] 백엔드 개발 부트캠프 13기 2주차</title>
        <link>http://localhost:1313/posts/week2-retrospective/</link>
        <pubDate>Fri, 27 Jun 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/week2-retrospective/</guid>
        <description>&lt;div style=&#34;margin: 0 40px;&#34;&gt;
&lt;h3 id=&#34;이번-주-키워드&#34;&gt;이번 주 키워드
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;객체 지향 설계&lt;/strong&gt;, &lt;strong&gt;클래스&lt;/strong&gt;, &lt;strong&gt;생성자&lt;/strong&gt;, &lt;strong&gt;추상클래스&lt;/strong&gt;, &lt;strong&gt;인터페이스&lt;/strong&gt;
&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;객체-지향이란&#34;&gt;객체 지향이란?
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;객체 지향(Object-Oriented Programming, OOP)&lt;/strong&gt; 은 현실 세계를 컴퓨터 안에 구현하는 방식 &lt;br&gt;
즉, 우리가 보는 세상처럼 데이터와 그 데이터를 다루는 행위를 &lt;strong&gt;객체&lt;/strong&gt;라는 단위로 묶어서 표현하는 것&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;실제 세계 분석, 관찰 → 설계(클래스 작성) → 객체 생성 → 객체 사용&lt;/p&gt;&lt;/blockquote&gt;
 &lt;br&gt;
&lt;p&gt;&lt;strong&gt;OOP의 목적&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드 재사용성을 높이고&lt;br&gt;&lt;/li&gt;
&lt;li&gt;유지보수를 쉽게 하며&lt;br&gt;&lt;/li&gt;
&lt;li&gt;변화에 유연하게 대응할 수 있도록 함&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;객체지향의-4대-원칙&#34;&gt;객체지향의 4대 원칙
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;캡슐화(Encapsulation)&lt;/strong&gt;&lt;br&gt;
데이터(변수)와 기능(메서드)을 하나로 묶고 외부에서 직접 접근하지 못하게 막음 &lt;br&gt;
→ 내부 구현은 숨기고, 인터페이스만 노출 &lt;br&gt;
→ 복잡도 감소, 유지보수 용이 &lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;상속(Inheritance)&lt;/strong&gt;&lt;br&gt;
기존 클래스를 확장하여 새로운 클래스를 생성 가능 &lt;br&gt;
→ 코드 중복을 줄이고 공통 로직을 한 곳에서 관리&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;추상화(Abstraction)&lt;/strong&gt;&lt;br&gt;
공통적인 성질만 뽑아서 일반화한 개념 &lt;br&gt;
→ 불필요한 정보는 숨기고 중요한 정보만 표현 &lt;br&gt;
→ 예: 동물 → 고양이/강아지 (공통 행동: 먹다, 자다)&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;다형성(Polymorphism)&lt;/strong&gt;&lt;br&gt;
하나의 참조변수로 여러 객체 다루기&lt;br&gt;
다형적 매개변수&lt;br&gt;
하나의 배열에 여러 객체 저장&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;클래스&#34;&gt;클래스
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;정의&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;설계도&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;변수 + 메서드&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;사용자 정의 타입&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;클래스 간의 관계&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;상속 관계 (is-a)&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;자식 클래스가 부모 클래스를 확장 &lt;br&gt;
→ ex) &lt;code&gt;Dog extends Animal&lt;/code&gt;&lt;br&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;* 자바는 단일 상속만 지원&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;포함 관계 (has-a)&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;하나의 클래스가 다른 클래스를 필드로 가짐 &lt;br&gt;
→ ex) &lt;code&gt;Person has a Address&lt;/code&gt;&lt;br&gt;&lt;br&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;변수의 종류&lt;/strong&gt;&lt;br&gt;
선언된 위치에 따라&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클래스 영역: class variable, instance variable&lt;/li&gt;
&lt;li&gt;메서드 영역: local variable&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;생성자&#34;&gt;생성자
&lt;/h3&gt;&lt;p&gt;변수의 초기화&lt;br&gt;
초기화 순서는 cv → iv, 자동(기본값) → 간단(대입 =) → 복잡({} 블럭) 순&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;조건&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;이름이 클래스와 동일&lt;/li&gt;
&lt;li&gt;반환타입 없음(void안씀)&lt;/li&gt;
&lt;li&gt;다른 생성자 호출은 반드시 첫줄에서&lt;/li&gt;
&lt;li&gt;다른 생성자 호출시 this() 사용&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;오버라이딩-vs-오버로딩&#34;&gt;오버라이딩 vs 오버로딩
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;오버라이딩(Overriding)&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;상속받은 메서드를 &lt;strong&gt;재정의&lt;/strong&gt;하는 것 &lt;br&gt;
→ 선언부는 같고, 구현부만 다르게 &lt;br&gt;
→ 접근제어자: 부모보다 좁으면 안됨 &lt;br&gt;
→ 반환 타입, 매개변수 동일해야 함&lt;br&gt;&lt;br&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;오버로딩(Overloading)&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;같은 이름의 메서드를 &lt;strong&gt;여러 개&lt;/strong&gt; 정의하는 것 &lt;br&gt;
→ 매개변수의 개수나 타입이 달라야 함&lt;br&gt;
→ 반환타입은 영향을 미치지 않음&lt;br&gt;&lt;br&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;super-키워드&#34;&gt;super 키워드
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;super&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;부모 클래스의 멤버(필드, 메서드)를 참조할 때 사용&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;code&gt;super()&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;부모 생성자를 호출할 때 사용&lt;br&gt;&lt;/li&gt;
&lt;li&gt;생성자의 첫 줄에는 반드시 &lt;code&gt;this()&lt;/code&gt; 또는 &lt;code&gt;super()&lt;/code&gt; 중 하나가 있어야 하며,&lt;br&gt;
없으면 컴파일러가 &lt;code&gt;super()&lt;/code&gt;를 자동 삽입함&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;다형성과-형변환&#34;&gt;다형성과 형변환
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;부모 타입으로 자식 객체를 참조할 수 있음 → 확장성과 유연성 확보&lt;br&gt;&lt;/li&gt;
&lt;li&gt;하지만 자식 타입으로 다시 형변환하려면 &lt;code&gt;instanceof&lt;/code&gt;로 확인해야 함&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (animal &lt;span style=&#34;color:#66d9ef&#34;&gt;instanceof&lt;/span&gt; Dog) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Dog dog &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (Dog) animal;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        dog.&lt;span style=&#34;color:#a6e22e&#34;&gt;bark&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;형변환을 통해 참조 변수(리모컨)를 바꿔 객체가 가진 메서드 범위를 조절&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;추상-클래스-abstract-class&#34;&gt;추상 클래스 (abstract class)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;미완성 설계도 → 객체 생성 불가&lt;br&gt;&lt;/li&gt;
&lt;li&gt;공통 부분은 구현하고, 바뀌는 부분만 추상 메서드로 정의&lt;br&gt;&lt;/li&gt;
&lt;li&gt;상속받은 클래스가 추상 메서드를 반드시 구현해야 함&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인터페이스-interface&#34;&gt;인터페이스 (interface)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;모든 메서드는 public abstract, 모든 변수는 public static final&lt;br&gt;
→ 생략해도 컴파일러가 자동 추가&lt;br&gt;
→ interface의 메서드를 오버라이딩하면 public을 반드시 붙여야 함&lt;/li&gt;
&lt;li&gt;다중 구현 가능&lt;br&gt;&lt;/li&gt;
&lt;li&gt;서로 관계없는 클래스에도 공통 기능 강제 가능&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;+) 추상클래스는 iv를 가질 수 있지만 인터페이스는 iv를 가질 수 없음&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;+) JDK 1.8 이후&lt;br&gt;
default, static 메서드 추가 가능&lt;br&gt;
→ 기존 구현 클래스에 영향 주지 않기 위해 도입&lt;br&gt;
→ default 메서드는 오버라이딩 가능&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Animal&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sound&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 추상 메서드&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Sleeping...&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;
&lt;hr&gt;
&lt;h2 id=&#34;마무리&#34;&gt;마무리
&lt;/h2&gt;&lt;p&gt;예전에 면접을 봤을 때 객체지향에 대한 질문을 받고 제대로 답변하지 못했던 적이 있었는데&lt;br&gt;
여러 번 반복을 하고 강사님께서 강조하신 부분을 외우려고 노력을 하고 나니&lt;br&gt;
이제 객체지향이 뭔지, 어떤 특징을 가지고 있는지 등에 대해 확실히 정리가 된 것 같다.&lt;br&gt;
욕심 부리지 않고 조금씩 이론적인 부분에 대해 정리하고 설명할 수 있는 능력을 길러야겠다!
&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
        </item>
        <item>
        <title>[커널아카데미] 백엔드 개발 부트캠프 13기 1주차]</title>
        <link>http://localhost:1313/posts/week1-retrospective/</link>
        <pubDate>Mon, 23 Jun 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/week1-retrospective/</guid>
        <description>&lt;div style=&#34;margin: 0 40px;&#34;&gt;
&lt;img src=&#34;http://localhost:1313/images/IMG_5618.jpeg&#34; alt=&#34;alt text&#34; style=&#34;width:50%;&#34; /&gt;
&lt;h3 id=&#34;이번-주-키워드&#34;&gt;이번 주 키워드
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;변수&lt;/strong&gt;, &lt;strong&gt;설계&lt;/strong&gt;
&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;변수란&#34;&gt;변수란?
&lt;/h3&gt;&lt;p&gt;자바에서 변수는 &lt;strong&gt;타입 + 이름&lt;/strong&gt;으로 구성&lt;br&gt;
이 변수를 통해 &lt;strong&gt;쓰기(= 연산자)&lt;/strong&gt;, &lt;strong&gt;읽기(변수명)&lt;/strong&gt; 등의 작업을 수행 가능&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;변수를 사용하는 이유?&lt;/strong&gt;&lt;br&gt;
→ &lt;strong&gt;컴파일러가 코드를 분석하고 오류를 사전에 잡을 수 있도록 하기 위해서&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;컴파일러는 다음과 같은 작업을 수행:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문법 체크&lt;/li&gt;
&lt;li&gt;최적화&lt;/li&gt;
&lt;li&gt;번역 (&lt;code&gt;.java&lt;/code&gt; → &lt;code&gt;.class&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;📌 즉, &lt;strong&gt;코드가 완벽하지 않아도&lt;/strong&gt; 컴파일러가 이를 어느 정도 보완해줌&lt;/p&gt;&lt;/blockquote&gt;
&lt;br&gt;
&lt;h3 id=&#34;변수의-종류&#34;&gt;변수의 종류
&lt;/h3&gt;&lt;p&gt;자바의 변수는 크게 두 가지:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;기본형(primitive)&lt;/strong&gt;: 하나의 요소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;참조형(reference)&lt;/strong&gt;: 여러 개의 요소(집합)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;참조형은 0~n개의 요소를 담는 &lt;strong&gt;집합&lt;/strong&gt;이며,&lt;br&gt;
이 집합을 만들기 위해서는 기준을 가지고 &lt;strong&gt;그룹화&lt;/strong&gt;를 수행&lt;br&gt;
➡️ 이것이 바로 &lt;strong&gt;설계&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h3 id=&#34;설계란&#34;&gt;설계란?
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;관련 있는 것끼리 하나의 집합으로 묶고 집합들 간의 관계를 정의&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;설계를 하면 좋은 점:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;복잡도가 낮아지고&lt;/li&gt;
&lt;li&gt;관리가 쉬워지며&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;더 복잡한 프로그램을 구현할 수 있게 됨&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h3 id=&#34;연산&#34;&gt;연산
&lt;/h3&gt;&lt;p&gt;연산이란 &lt;strong&gt;데이터를 계산하는 것&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;같은 타입끼리만 연산 가능&lt;/li&gt;
&lt;li&gt;반드시 &lt;strong&gt;결과를 반환&lt;/strong&gt;해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;연산자에서 중요한 3요소:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;우선순위&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;결합법칙&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;산술 변환&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;둘 중 큰 타입으로 자동 변환&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;보다 작은 타입끼리 연산 시 → &lt;strong&gt;&lt;code&gt;int&lt;/code&gt;로 변환 후 연산&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h3 id=&#34;연습문제-정리&#34;&gt;연습문제 정리
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;long&lt;/code&gt;형 변수에 정수값 저장 시 &lt;code&gt;L&lt;/code&gt;을 붙이지 않으면 기본적으로 &lt;code&gt;int&lt;/code&gt;로 인식&lt;br&gt;
→ &lt;code&gt;int&lt;/code&gt; 범위 초과 시 컴파일 에러 발생&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&#39;+&#39;&lt;/code&gt; 연산자는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;둘 다 숫자 → &lt;strong&gt;덧셈&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;하나라도 String → &lt;strong&gt;문자열 이어붙이기&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char + char&lt;/code&gt; / &lt;code&gt;char + 숫자&lt;/code&gt; → &lt;strong&gt;int 반환&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;단, &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt; 같은 증감 연산자는 &lt;strong&gt;형변환 없이&lt;/strong&gt; &lt;code&gt;char&lt;/code&gt;로 반환&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자바는 C처럼 &lt;code&gt;0 = false&lt;/code&gt;, &lt;code&gt;1 = true&lt;/code&gt;를 인정하지 않음&lt;br&gt;
→ &lt;code&gt;boolean&lt;/code&gt;에는 반드시 &lt;strong&gt;&lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt;&lt;/strong&gt; 를 사용해야 함&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;는 요소형 → 반드시 문자를 지정해야 함&lt;br&gt;
→ &lt;code&gt;&#39;&#39;&lt;/code&gt; (빈 문자 리터럴) 사용 불가&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h3 id=&#34;자바에서의-var&#34;&gt;자바에서의 &lt;code&gt;var&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;Java 10부터 도입된 문법으로, &lt;strong&gt;로컬 변수의 타입을 컴파일러가 자동 추론&lt;/strong&gt;&lt;br&gt;
(컴파일 타임에 정적으로 결정, 런타임에 동적으로 바뀌지 않음)&lt;br&gt;
적절한 상황에 사용하면 &lt;strong&gt;코드의 가독성과 간결성&lt;/strong&gt;이 좋아짐&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;1-타입이-너무-길어서-코드가-지저분할-때&#34;&gt;1. 타입이 너무 길어서 코드가 지저분할 때
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// before&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String, List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; HashMap&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// after&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; HashMap&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String, List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;2-우측-표현식으로-타입이-분명히-드러날-때&#34;&gt;2. 우측 표현식으로 타입이 분명히 드러날 때
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Soyeon&amp;#34;&lt;/span&gt;;      &lt;span style=&#34;color:#75715e&#34;&gt;// String&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 123;          &lt;span style=&#34;color:#75715e&#34;&gt;// int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; List.&lt;span style=&#34;color:#a6e22e&#34;&gt;of&lt;/span&gt;(1, 2); &lt;span style=&#34;color:#75715e&#34;&gt;// List&amp;lt;Integer&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;3-for-each-루프에서-반복-변수&#34;&gt;3. for-each 루프에서 반복 변수
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; item : items) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(item);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;📌 주의:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;var는 명시적인 타입 지정이 아닌 추론이기 때문에, 복잡한 표현식에서는 오히려 가독성을 해칠 수 있음&lt;/li&gt;
&lt;li&gt;클래스 필드, 메서드 매개변수, 리턴 타입에는 사용할 수 없음 (오직 로컬 변수에만 사용 가능)
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;→ 사람이 읽을 수 있을 만큼만 추론을 맡기고 그렇지 않으면 명시적으로 타입을 작성하자!&lt;/strong&gt;
&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;마무리&#34;&gt;마무리
&lt;/h2&gt;&lt;p&gt;java 기초 부분은 어느 정도 안다고 생각했는데 연습문제를 풀어보니&lt;br&gt;
컴파일러가 있어서 아무 생각 없이 코드를 작성하던 부분이 많았다는 것을 느꼈다.&lt;br&gt;
예습 복습을 하면서 기초를 탄탄히 다져야겠다!
&lt;br&gt;&lt;br&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
