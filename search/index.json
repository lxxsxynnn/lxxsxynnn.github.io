[{"content":" 이번 주 키워드 객체 지향 설계, 클래스, 생성자, 추상클래스, 인터페이스 객체 지향이란? 객체 지향(Object-Oriented Programming, OOP) 은 현실 세계를 컴퓨터 안에 구현하는 방식 즉, 우리가 보는 세상처럼 데이터와 그 데이터를 다루는 행위를 객체라는 단위로 묶어서 표현하는 것\n실제 세계 분석, 관찰 → 설계(클래스 작성) → 객체 생성 → 객체 사용\nOOP의 목적\n코드 재사용성을 높이고\n유지보수를 쉽게 하며\n변화에 유연하게 대응할 수 있도록 함\n객체지향의 4대 원칙 캡슐화(Encapsulation)\n데이터(변수)와 기능(메서드)을 하나로 묶고 외부에서 직접 접근하지 못하게 막음 → 내부 구현은 숨기고, 인터페이스만 노출 → 복잡도 감소, 유지보수 용이 상속(Inheritance)\n기존 클래스를 확장하여 새로운 클래스를 생성 가능 → 코드 중복을 줄이고 공통 로직을 한 곳에서 관리\n추상화(Abstraction)\n공통적인 성질만 뽑아서 일반화한 개념 → 불필요한 정보는 숨기고 중요한 정보만 표현 → 예: 동물 → 고양이/강아지 (공통 행동: 먹다, 자다)\n다형성(Polymorphism)\n하나의 참조변수로 여러 객체 다루기\n다형적 매개변수\n하나의 배열에 여러 객체 저장\n클래스 정의\n설계도 변수 + 메서드 사용자 정의 타입 클래스 간의 관계\n상속 관계 (is-a) 자식 클래스가 부모 클래스를 확장 → ex) Dog extends Animal\n* 자바는 단일 상속만 지원\n포함 관계 (has-a) 하나의 클래스가 다른 클래스를 필드로 가짐 → ex) Person has a Address\n변수의 종류\n선언된 위치에 따라\n클래스 영역: class variable, instance variable 메서드 영역: local variable 생성자 변수의 초기화\n초기화 순서는 cv → iv, 자동(기본값) → 간단(대입 =) → 복잡({} 블럭) 순\n조건\n이름이 클래스와 동일 반환타입 없음(void안씀) 다른 생성자 호출은 반드시 첫줄에서 다른 생성자 호출시 this() 사용 오버라이딩 vs 오버로딩 오버라이딩(Overriding) 상속받은 메서드를 재정의하는 것 → 선언부는 같고, 구현부만 다르게 → 접근제어자: 부모보다 좁으면 안됨 → 반환 타입, 매개변수 동일해야 함\n오버로딩(Overloading) 같은 이름의 메서드를 여러 개 정의하는 것 → 매개변수의 개수나 타입이 달라야 함\n→ 반환타입은 영향을 미치지 않음\nsuper 키워드 super\n부모 클래스의 멤버(필드, 메서드)를 참조할 때 사용\nsuper()\n부모 생성자를 호출할 때 사용\n생성자의 첫 줄에는 반드시 this() 또는 super() 중 하나가 있어야 하며,\n없으면 컴파일러가 super()를 자동 삽입함\n다형성과 형변환 부모 타입으로 자식 객체를 참조할 수 있음 → 확장성과 유연성 확보\n하지만 자식 타입으로 다시 형변환하려면 instanceof로 확인해야 함\nif (animal instanceof Dog) { Dog dog = (Dog) animal; dog.bark(); } 형변환을 통해 참조 변수(리모컨)를 바꿔 객체가 가진 메서드 범위를 조절\n추상 클래스 (abstract class) 미완성 설계도 → 객체 생성 불가\n공통 부분은 구현하고, 바뀌는 부분만 추상 메서드로 정의\n상속받은 클래스가 추상 메서드를 반드시 구현해야 함\n인터페이스 (interface) 모든 메서드는 public abstract, 모든 변수는 public static final\n→ 생략해도 컴파일러가 자동 추가\n→ interface의 메서드를 오버라이딩하면 public을 반드시 붙여야 함 다중 구현 가능\n서로 관계없는 클래스에도 공통 기능 강제 가능\n+) 추상클래스는 iv를 가질 수 있지만 인터페이스는 iv를 가질 수 없음\n+) JDK 1.8 이후\ndefault, static 메서드 추가 가능\n→ 기존 구현 클래스에 영향 주지 않기 위해 도입\n→ default 메서드는 오버라이딩 가능\ninterface Animal { void sound(); // 추상 메서드 default void sleep() { System.out.println(\u0026#34;Sleeping...\u0026#34;); } } 마무리 예전에 면접을 봤을 때 객체지향에 대한 질문을 받고 제대로 답변하지 못했던 적이 있었는데\n여러 번 반복을 하고 강사님께서 강조하신 부분을 외우려고 노력을 하고 나니\n이제 객체지향이 뭔지, 어떤 특징을 가지고 있는지 등에 대해 확실히 정리가 된 것 같다.\n욕심 부리지 않고 조금씩 이론적인 부분에 대해 정리하고 설명할 수 있는 능력을 길러야겠다! ","date":"2025-06-27T00:00:00Z","permalink":"http://localhost:1313/posts/week2-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 2주차"},{"content":" 이번 주 키워드 변수, 설계 변수란? 자바에서 변수는 타입 + 이름으로 구성\n이 변수를 통해 쓰기(= 연산자), 읽기(변수명) 등의 작업을 수행 가능\n변수를 사용하는 이유?\n→ 컴파일러가 코드를 분석하고 오류를 사전에 잡을 수 있도록 하기 위해서\n컴파일러는 다음과 같은 작업을 수행:\n문법 체크 최적화 번역 (.java → .class) 📌 즉, 코드가 완벽하지 않아도 컴파일러가 이를 어느 정도 보완해줌\n변수의 종류 자바의 변수는 크게 두 가지:\n기본형(primitive): 하나의 요소 참조형(reference): 여러 개의 요소(집합) 참조형은 0~n개의 요소를 담는 집합이며,\n이 집합을 만들기 위해서는 기준을 가지고 그룹화를 수행\n➡️ 이것이 바로 설계\n설계란? 관련 있는 것끼리 하나의 집합으로 묶고 집합들 간의 관계를 정의\n설계를 하면 좋은 점:\n복잡도가 낮아지고 관리가 쉬워지며 더 복잡한 프로그램을 구현할 수 있게 됨 연산 연산이란 데이터를 계산하는 것\n같은 타입끼리만 연산 가능 반드시 결과를 반환해야 함 연산자에서 중요한 3요소:\n우선순위 결합법칙 산술 변환 둘 중 큰 타입으로 자동 변환 int보다 작은 타입끼리 연산 시 → int로 변환 후 연산 연습문제 정리 long형 변수에 정수값 저장 시 L을 붙이지 않으면 기본적으로 int로 인식\n→ int 범위 초과 시 컴파일 에러 발생\n'+' 연산자는\n둘 다 숫자 → 덧셈 하나라도 String → 문자열 이어붙이기 char + char / char + 숫자 → int 반환 단, ++, -- 같은 증감 연산자는 형변환 없이 char로 반환\n자바는 C처럼 0 = false, 1 = true를 인정하지 않음\n→ boolean에는 반드시 true / false 를 사용해야 함\nchar는 요소형 → 반드시 문자를 지정해야 함\n→ '' (빈 문자 리터럴) 사용 불가\n자바에서의 var Java 10부터 도입된 문법으로, 로컬 변수의 타입을 컴파일러가 자동 추론\n(컴파일 타임에 정적으로 결정, 런타임에 동적으로 바뀌지 않음)\n적절한 상황에 사용하면 코드의 가독성과 간결성이 좋아짐\n1. 타입이 너무 길어서 코드가 지저분할 때 // before Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // after var map = new HashMap\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt;(); 2. 우측 표현식으로 타입이 분명히 드러날 때 var name = \u0026#34;Soyeon\u0026#34;; // String var count = 123; // int var list = List.of(1, 2); // List\u0026lt;Integer\u0026gt; 3. for-each 루프에서 반복 변수 for (var item : items) { System.out.println(item); } 📌 주의:\nvar는 명시적인 타입 지정이 아닌 추론이기 때문에, 복잡한 표현식에서는 오히려 가독성을 해칠 수 있음 클래스 필드, 메서드 매개변수, 리턴 타입에는 사용할 수 없음 (오직 로컬 변수에만 사용 가능) → 사람이 읽을 수 있을 만큼만 추론을 맡기고 그렇지 않으면 명시적으로 타입을 작성하자! 마무리 java 기초 부분은 어느 정도 안다고 생각했는데 연습문제를 풀어보니\n컴파일러가 있어서 아무 생각 없이 코드를 작성하던 부분이 많았다는 것을 느꼈다.\n예습 복습을 하면서 기초를 탄탄히 다져야겠다! ","date":"2025-06-23T00:00:00Z","permalink":"http://localhost:1313/posts/week1-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 1주차]"}]