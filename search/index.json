[{"content":" 네트워크 기초 및 심화 종합 정리 1. 네트워크란? 컴퓨터와 장치들이 데이터를 주고받는 통신 체계다.\nLAN(근거리), WAN(광역), 인터넷 등 다양한 형태와 규모가 존재 주 목적은 원격 자원 접근과 데이터 공유, 통신 서비스 제공 2. 네트워크 주요 용어 용어 설명 IP 주소 네트워크 상의 장치 식별을 위한 고유 주소 MAC 주소 물리적 네트워크 인터페이스의 고유 식별자 포트 장치 내 서비스 구분을 위한 번호 소켓 IP 주소와 포트 번호의 조합으로 된 네트워크 통신 종착점 패킷 네트워크 상 데이터 전송 단위 프로토콜 통신을 위한 규칙과 절차 라우터 네트워크 간 데이터 전달 장치 스위치 같은 네트워크 내 데이터 중계 장치 DNS 도메인명을 IP 주소로 변환하는 서비스 3. OSI 7계층 모델 상세 계층 번호 이름 주요 기능 및 설명 주요 프로토콜 예 7 응용 계층 사용자와 직접 상호작용, 애플리케이션 서비스 제공 HTTP, FTP, SMTP, DNS 6 표현 계층 데이터 표현과 암호화, 압축 JPEG, ASCII, TLS 5 세션 계층 세션 설정, 유지, 종료 NetBIOS, SAP 4 전송 계층 데이터 전송, 오류 제어, 흐름 제어 TCP, UDP 3 네트워크 계층 패킷 라우팅, IP 주소 관리 IP, ICMP 2 데이터 링크 계층 프레임 전송, MAC 주소 관리, 에러 검출 및 수정 Ethernet, PPP 1 물리 계층 전기 신호, 케이블 등 물리 매체의 실제 전송 Ethernet physical, USB 4. TCP/IP 4계층 모델 심화 계층 역할 상세 원리 및 주요 명령어/프로토콜 링크 계층 물리 데이터 전송 및 에러 제어 Ethernet, Wi-Fi, ARP; 주요 명령어: ifconfig, tcpdump 인터넷 계층 IP 기반 패킷 전송 및 라우팅 IPv4, IPv6, ICMP; 주요 명령어: ping, traceroute 전송 계층 신뢰성 있는 데이터 전송, 오류 복구 TCP(3-way handshake, seq/ack), UDP; netstat 사용 응용 계층 애플리케이션 서비스 프로토콜 HTTP/HTTPS(curl, Postman), FTP, DNS 조회 명령어 5. IP 주소 및 서브넷팅 상세 IPv4: 32bit 주소, 4옥텟으로 표현 (ex. 192.168.0.1) 서브넷 마스크: 네트워크/호스트 구분 위해 사용 CIDR 표기법: 192.168.1.0/24 (앞 24비트 네트워크 부분) IPv6: 128bit 주소, 넓은 주소 공간과 보안성 강화 명령어: ipconfig(Windows), ifconfig(Linux/Mac), route, netstat -r 6. 포트와 소켓 포트 번호 범위: 0~65535 0~1023 웰노운 포트(HTTP 80, HTTPS 443 등) 1024~49151 등록 포트 49152~65535 동적/임시 포트 소켓 = IP 주소 + 포트 번호 (통신 단위) 주요 시스템 콜: socket(), bind(), listen(), accept(), connect() 소켓 상태: LISTEN, SYN_SENT, ESTABLISHED, CLOSE_WAIT, TIME_WAIT 명령어 예: netstat -an, ss -tuln 7. HTTP/HTTPS 심화 HTTP: 텍스트 기반 무상태 프로토콜, GET/POST/PUT/DELETE 등 메서드 지원 HTTPS: TLS/SSL 암호화와 인증서 제공, 데이터 무결성 보장 HTTP/2: 헤더 압축, 멀티플렉싱, 서버 푸시 HTTP/3(QUIC): UDP 기반, 저지연 통신 8. 네트워크 통신 흐름 심화 클라이언트가 도메인명으로 DNS 질의 DNS가 IP 주소 반환 TCP 3-way handshake로 연결 수립 HTTP 요청 및 응답 교환 (HTTPS) TLS 인증서 교환 및 암호화 과정 연결 유지 혹은 종료(Keep-Alive 옵션) 9. NAT와 포트포워딩 NAT: 사설 IP주소를 공인 IP주소로 변환, 네트워크 보안 및 주소 절약 목적 포트포워딩: 외부 요청을 내부 네트워크 특정 IP 및 포트로 전달 방화벽과 병행해 서비스 접근을 제어함 10. 실무와 면접 팁 TCP와 UDP의 특징과 용도 차이 숙지 방화벽, NAT 문제 발생 시 해결법 익히기 SSL/TLS 인증서 설정 시 유의점과 절차 이해 CORS 정책 문제 이해 및 해결 방법 소켓 프로그래밍 API 이해 및 활용 11. 확장 및 응용 사례 RESTful API와 GraphQL의 네트워크 차이 WebSocket 기반 양방향 실시간 통신 설계 및 구현 스프링 WebFlux를 활용한 리액티브 네트워크 프로그래밍 이해 로드밸런싱 및 네트워크 보안 기법 12. 주요 명령어 및 코드 예제 네트워크 주요 명령어 ipconfig # 윈도우 IP 정보 ifconfig # 리눅스/Mac IP 정보 ping google.com # 연결 테스트 traceroute google.com # 리눅스 경로 추적 tracert google.com # 윈도우 경로 추적 netstat -an # 소켓 및 포트 상태 ss -tuln # 리눅스 소켓 상세 정보 nslookup example.com # DNS 조회 Java TCP 서버 예제 import java.io.*; import java.net.*; public class TcpServer { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(5000); System.out.println(\u0026#34;서버 대기 중...\u0026#34;); Socket clientSocket = serverSocket.accept(); BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true); String line; while ((line = in.readLine()) != null) { System.out.println(\u0026#34;클라이언트: \u0026#34; + line); out.println(\u0026#34;echo: \u0026#34; + line); if (\u0026#34;bye\u0026#34;.equalsIgnoreCase(line)) break; } clientSocket.close(); serverSocket.close(); } } Java TCP 클라이언트 예제 import java.io.*; import java.net.*; public class TcpClient { public static void main(String[] args) throws IOException { Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 5000); BufferedReader keyboard = new BufferedReader(new InputStreamReader(System.in)); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); String userInput; while ((userInput = keyboard.readLine()) != null) { out.println(userInput); System.out.println(\u0026#34;서버 응답: \u0026#34; + in.readLine()); if (\u0026#34;bye\u0026#34;.equalsIgnoreCase(userInput)) break; } socket.close(); } } 13. 네트워크 통신 과정 도식화 [Application Layer (HTTP/FTP 등)] ↓ [Transport Layer (TCP/UDP) - 3-way Handshake] ↓ [Internet Layer (IP, 라우팅)] ↓ [Data Link Layer (MAC, 프레임)] ↓ [Physical Layer (전기 신호, 케이블)] ↓ (물리 전송 매체 → 수신 측은 역순으로 헤더 해체 후 응용까지 전달) ","date":"2025-09-20T00:00:00Z","permalink":"http://localhost:1313/posts/week14-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 CS 정리 - 네트워크 기초와 심화"},{"content":" 13주차 학습정리 - 운영체제 1. 정의와 목적 운영체제(OS): 컴퓨터의 하드웨어 및 소프트웨어 자원을 관리·제어하고,\n사용자와 응용 프로그램에 대해 통합적·효율적 서비스를 제공하는 시스템 소프트웨어 대표 예시: Windows, macOS, Linux, Android, iOS 등 2. 구성과 구조 전체 구조 하드웨어 커널(Kernel): OS의 핵심, 자원관리·프로세스·메모리·파일·I/O 등 주요기능 수행 셸(Shell): 사용자 인터페이스(터미널·명령어·그래픽 등) 응용프로그램/App 사용자 및 외부장치 계층 관계(도식) [사용자] | [셸/앱] | [운영체제(OS) - 커널] | [하드웨어 (CPU, 메모리, 디스크, 네트워크, I/O장치)] 3. 핵심 역할과 기능 자원 관리(Resource Management)\nCPU, 메모리, 저장장치, 입출력장치 등 자원 배분·제어[1] 프로세스/스레드 관리(Process/Thread Management)\n실행중인 프로그램, 스케줄링(순서관리), 생성/종료/상태관리 멀티태스킹 지원(동시 실행 효과) 스레드 : 내부 작업단위, 메모리 공유 메모리 관리(Memory Management)\n프로세스/프로그램별 메모리 할당/회수/배치 가상 메모리, 페이징 등 효율화 기법 파일 시스템 관리(File System Management)\n데이터 저장/읽기/삭제, 파일·디렉토리 구조 제공 입출력(I/O) 및 장치관리\n키보드, 마우스, 프린터, 디스플레이 등 연결·제어 드라이버(Driver) 통한 하드웨어/OS 연동 보안 및 권한(Security \u0026amp; Authorization)\n자원 접근권한, 사용자 인증, 데이터 보호 네트워킹\n시스템 간 통신, 네트워크 자원 관리(소켓, TCP/IP) 시스템 서비스 및 API\n응용프로그램이 OS 서비스 이용할 수 있도록 시스템콜 제공 4. 용어 및 주요 원리 용어 설명 커널 OS 핵심, 자원·스케줄링·메모리 관리 셸 사용자와 OS간 인터페이스 (명령/그래픽 등) 프로세스 실행중인 프로그램 인스턴스 스레드 프로세스 내 작업 실행 단위 시스템콜 프로그램↔OS 인터페이스용 함수 드라이버 하드웨어↔OS 연동 소프트웨어 파일 시스템 저장·검색·구조화·삭제를 위한 OS 서비스 가상 메모리 실제·논리 메모리 분리, 효율증대 멀티태스킹 여러 앱·프로세스를 동시에 실행 5. OS 종류와 특징 데스크탑/서버 OS: Windows, macOS, Linux (다중 사용자/프로세스, 보안기능↑) 모바일/임베디드 OS: Android, iOS, RTOS 등 (경량화, 실시간 처리, 장치특화) 기타: UNIX, BSD, 하이퍼바이저(가상화 OS) 6. 프로세스 관리와 문맥 전환 프로세스(Process)와 스레드(Thread)의 차이 프로세스: 실행 중인 프로그램의 인스턴스, 별도의 메모리 공간과 자원을 가짐 스레드: 프로세스 내 실행 단위, 프로세스 자원(메모리, 변수)을 공유 프로세스 간 독립성 높고, 스레드는 경량 프로세스라고도 불림 문맥 전환(Context Switching) CPU가 한 프로세스에서 다른 프로세스로 전환할 때 이전 프로세스 상태(레지스터, PC 등)를 저장하고,\n다음 프로세스 상태를 복원하는 작업 비용이 크고 빈번한 전환은 성능 저하 원인 PCB(Process Control Block) 각 프로세스의 상태와 정보(프로세스 ID, 상태, 레지스터, 메모리 정보, 스케줄링 정보 등)를 저장하는 데이터 구조 OS는 PCB를 이용해 프로세스 실행 상태 관리 프로세스 상태 변화 예시 대기(Ready) → 실행(Running) → 대기(Waiting) → 종료(Terminated) 상태 전이 시 PCB 업데이트와 문맥 전환 발생 7. 스케줄링 알고리즘 알고리즘 설명 장점 단점 FCFS 먼저 온 요청부터 처리 구현 단순, 공정함 긴 작업이 전체 대기 시간 증가(Convoy 효과) SJF 실행 시간이 짧은 작업 먼저 처리 평균 대기시간 최소화 긴 작업이 무한 대기 가능(Starvation) Priority 우선순위 높은 작업 먼저 처리 중요한 작업 우선 수행 가능 낮은 우선순위 작업 무한대기 위험 RR (Round Robin) 정해진 시간으로 순환 공평한 CPU 시간 분배 짧은 시간 할당 시 문맥 전환 과다 멀티레벨 큐 여러 큐로 작업 분리, 각 큐별 스케줄링 다양한 우선순위/형태 지원 복잡한 관리, 프로세스 이동 정책 필요 실무 시스템/서버 적용 사례 서버는 RR 기반 멀티태스킹+우선순위 혼합 적용 실시간 시스템은 Priority 스케줄링 혹은 Rate-monotonic 대형 OS(리눅스 등)는 멀티레벨 피드백 큐 스케줄링 사용 8. 메모리 관리 기본 개념 메모리 주소를 효율적으로 할당·회수하고 보호 실제 물리 메모리와 가상 메모리를 분리해 관리 페이징(Paging) 메모리를 고정 크기 블록(페이지)으로 분리하여 할당 페이지 단위로 물리 메모리 대응, 내부 단편화 최소화 세그먼테이션(Segmentation) 프로그램을 의미 단위(코드, 데이터, 스택 등)로 분할하여 관리 논리적 구조 반영이 용이하나 외부 단편화 발생 가능 가상 메모리 실제 메모리보다 큰 메모리 공간 제공 필요시 디스크에 ‘스왑(swapping)’하여 메모리 부족 해소 페이지 폴트(Page Fault) 페이지가 메모리에 없을 때 발생하는 인터럽트 OS가 디스크에서 적절한 페이지를 메모리로 로드 현대 OS 메모리 관리 사례 요구 페이징, 메모리 보호, 공유 메모리, 메모리 매핑 파일 리눅스, 윈도우 등에서 다양한 기법 조합 적용 9. 동기화와 병행성 임계 구역(Critical Section) 다중 스레드가 동시에 접근 시 문제가 생기는 공유 자원 접근 구간 동기화 도구 뮤텍스(Mutex): 상호 배제 자원 잠금 세마포어(Semaphore): 자원 수 계산 및 접근 제한 모니터(Monitor): 뮤텍스+조건변수, 구조화된 동기화 제공 동기화 필요 이유 데이터 일관성 및 무결성 보장을 위해 필수 동기화 문제점 데드락(Deadlock) : 자원 순환 대기로 작업 정지 라이브락(Livelock) : 반복 응답하지만 처리 못함 병행 프로그래밍 실전 적절한 락 사용, 최소화 불변 객체 활용 원자성 보장 코드 작성 10. 파일 시스템 파일 시스템 원리 데이터 저장소를 파일과 폴더 구조로 추상화하여 관리 데이터 추가, 삭제, 검색 기능 파일 시스템 종류 FAT(File Allocation Table): 간단, 플로피 디스크용 NTFS(New Technology File System): 윈도우 주력 ext3, ext4: 리눅스에서 널리 사용하는 저널링 파일 시스템 파일 입출력 및 권한 관리 OS API 통해 파일 열기, 읽기, 쓰기, 닫기 수행 권한은 소유자, 그룹, 기타 사용자 별로 읽기, 쓰기, 실행 구분 정리 운영체제의 핵심 기능인 프로세스와 스레드 관리, 문맥 전환을 이해하고 스케줄링 알고리즘을 익히는 것은\n효율적인 CPU 사용과 멀티태스킹 구현의 기본\n메모리 관리 기법 - 자원 최적화와 시스템 안정성에 직결\n동기화 이슈 - 병행 처리에서 데이터 일관성을 보장하는 필수 요소\n파일 시스템 - 영속적 데이터 저장과 관리의 근간으로, 운영체제 전반의 이해를 완성하는 중요한 주제\n","date":"2025-09-14T00:00:00Z","permalink":"http://localhost:1313/posts/week13-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 13주차"},{"content":" 12주차 학습 정리 - Spring AI \u0026amp; TCP/IP 이번 주 키워드 Spring AI 프레임워크 생성형 AI와 LLM 연동(RAG, Tool Calling) Spring Boot와 AI 통합 TCP/IP 네트워크 기초와 실무 1. Spring AI란? Spring AI는 자바 기반 스프링 생태계에서 생성형 AI 기능(LLM, 벡터DB 등)을 쉽고 일관되게 활용할 수 있도록 만든 프레임워크 OpenAI, Anthropic, Microsoft, Google 등 주요 AI 모델 및 Chroma, Pinecone 등 여러 벡터DB와 빠르게 연동 가능 기존 Spring Boot 환경에 자동 구성(Auto Configuration), 다양한 LLM API 지원, RAG(검색 증강 생성),\n툴 콜링, 실시간 스트리밍 API 등 최신 AI 관련 기능을 간단하게 추가 가능 2. Spring AI의 주요 특징 자동 설정 \u0026amp; 스타터 의존성: 복잡한 설정 없이 거의 바로 서비스 개발이 가능 다양한 AI/데이터베이스 연동: 주요 AI 모델, 문서·테이블 기반 RAG 시스템, 실시간 챗봇 등 빠르게 구현 툴 호출 기능: AI가 실시간으로 클라이언트 함수나 외부 API를 직접 실행할 수 있음 출력 매핑·스트리밍 지원: 생성형 응답을 자바 객체(POJO)로 바로 연결, 대형 모델 응답 스트리밍까지 지원 실무 활용 예시: 내 문서/PDF 기반 QnA 챗봇 외부 API 연동형 생성형 응답 서비스 데이터베이스 문서 검색 + RAG AI 결과 실시간 모니터링(Actuator, Observability) 3. TCP/IP 네트워크 기초 TCP/IP 4계층 모델\nNetwork Interface: 실제 신호 전달(Ethernet, MAC) Internet(IP): 패킷 라우팅, 경로 지정 Transport(TCP/UDP): TCP: 신뢰성, 순서 보장, 패킷 재전송, 오류 검출 UDP: 비신뢰, 빠른 전송 Application Layer: HTTP, FTP, WebSocket 등 실제 서비스 작동 흐름\n송신: Application 계층(HTTP 등) → Transport(TCP: 포트) → Internet(IP) → Network Interface로 캡슐화 수신: 반대로 해체(역캡슐화)해 최종 Application 데이터로 Spring Boot/Spring AI 연동에 미치는 영향\n모든 REST API/LLM 챗봇/WebSocket 등은 실제로 TCP/IP로 연결됨 HTTPS, WSS(WebSocket Secure)=TCP 기반 암호화 프로토콜 서버/클라이언트가 도메인, 포트, 프로토콜이 다르면 인증서, CORS, Origin 등의 네트워크/보안 설정을 항상 신경 써야 함 4. 배운 점 \u0026amp; 느낀 점 지금 진행 중인 토이 프로젝트 배포 환경에서 프론트엔드와 백엔드 도메인이 달라서\nCORS 에러, 인증서 적용, 보안 정책 등 여러 네트워크 문제를 직접 경험했다.\n기존에는 http로만 단순히 API를 연결하는 게 전부처럼 느껴졌지만,\n실제로 안정적인 서비스와 실시간 통신을 지원하려면\nTCP/IP와 애플리케이션 계층(HTTP, WSS 등)의 동작 원리까지 제대로 이해하는 게 필수라는 점을 절실히 알게 되었다.\n이번에 Spring AI를 배우면서, 단순히 최신 프레임워크만 다루는 게 아니라\n서버와 클라이언트가 어떻게 서로 데이터를 주고받고, 네트워크 내부에서 어떤 문제가 발생할 수 있는지\n그리고 그 문제를 제대로 해결하기 위해서는 기초가 되는 TCP/IP와 같은 네트워크 구조까지 함께 신경 쓰는 것이 중요하다는 사실을 다시 깨달았다.\nSpring Boot와 Spring AI가 제공하는 높은 개발 생산성과 편의성에 기대는 것도 좋지만,\n결국 실무에서는 네트워크 구조, 보안, 통신 정책까지 꼼꼼히 신경 써야 제대로 동작하는 백엔드 서비스를 만들 수 있다는 점을 이번 주에 깊이 인식했다.\n","date":"2025-09-07T00:00:00Z","permalink":"http://localhost:1313/posts/week12-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 12주차"},{"content":" 11주차 학습 정리 이번 주 키워드 Spring Boot 자동 설정 JPA와 ORM Spring Data JPA (Repository, 쿼리 메서드) 필터(Filter)와 인터셉터(Interceptor) 1. 의존성 관리와 자동 설정 스타터(Starters): 기능별 의존성 묶음 pom.xml에 추가 시 관련 라이브러리들이 자동으로 추가됨 @SpringBootApplication : @Configuration + @ComponentScan + @EnableAutoConfiguration의 조합 자동 설정(Auto-configuration) @EnableAutoConfiguration이 핵심 기능 클래스패스 등 특정 조건에 따라 필요한 빈(Bean)을 자동으로 설정 @Conditional : 조건부 빈 등록 기능\n@ConditionalOnClass(클래스 존재 시), @ConditionalOnBean(빈 존재 시) 등 다양한 조건을 제공 2. ORM과 JPA ORM(Object-Relational Mapping): 객체와 관계형 DB 테이블을 매핑하는 기술\n객체 모델과 관계형 모델의 개념 차이를 해소\nJPA(Java Persistence API): 자바 ORM 기술의 표준 API\nHibernate가 가장 대표적인 구현체\nEntityManagerFactory: EntityManager를 생성하는 팩토리\n애플리케이션 전체에서 하나만 생성\nEntityManager: 엔티티를 관리(저장, 조회, 삭제)하는 핵심 객체\n엔티티(Entity): DB 테이블과 매핑되는 자바 클래스 @Entity로 지정하며 @Id로 PK를 표시\n영속성 컨텍스트(Persistence Context): 엔티티를 보관하는 공간(1차 캐시)\n엔티티의 변경 사항을 감지(Dirty Checking)하고 트랜잭션 커밋 시 DB에 자동으로 반영\n3. Spring Data JPA Spring Data JPA: JPA를 더 쉽고 일관되게 사용하도록 돕는 스프링 프로젝트\nJpaRepository와 같은 저장소 기능 제공\nJpaRepository: CrudRepository, PagingAndSortingRepository를 상속받아 CRUD, 페이징, 정렬 기능을 기본으로 제공하는 인터페이스\n쿼리 메서드(Query Method): 메서드 이름으로 JPQL을 자동 생성하는 기능\n예시: List findByWriter(String writer);\nJPQL(Java Persistence Query Language): DB 테이블이 아닌 엔티티 객체를 대상으로 하는 쿼리 언어\n@Query 어노테이션으로 직접 작성 가능\nQuerydsl: JPQL을 문자열이 아닌 타입에 안전한(Type-safe) 자바 코드로 작성하게 해주는 프레임워크\n4. Filter와 Interceptor 공통점: 요청에 대한 공통적인 전처리(pre-processing)와 후처리(post-processing)에 사용 (예: 로깅, 인코딩) Filter (필터) 서블릿(Servlet) 스펙에 포함된 기능 요청이 DispatcherServlet에 도달하기 전에 동작 스프링 컨테이너와 무관하게 동작하므로 빈(Bean) 주입이 불가능 Interceptor (인터셉터) Spring MVC 프레임워크가 제공하는 기능 DispatcherServlet과 컨트롤러 사이에서 동작. 스프링 컨테이너의 일부이므로 빈(Bean) 주입이 가능 로그인 인증, 권한 체크 등 비즈니스 로직과 연관된 처리에 주로 사용 ","date":"2025-08-31T00:00:00Z","permalink":"http://localhost:1313/posts/week11-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 11주차"},{"content":" 10주차 학습 정리 - 2 이번 주 키워드 JavaScript 기본 문법 (자료형, 호이스팅, 스코프) 객체와 프로토타입 (Object \u0026amp; Prototype) DOM (Document Object Model) 조작 이벤트(Event) 처리 모델 1. JavaScript 기본 문법 Java와 이름은 비슷하지만 동작 방식이 매우 다른 웹 브라우저를 제어하기 위한 핵심 언어\n자료형(Data Types) \u0026amp; 동적 타이핑 동적 타입 언어: 변수의 타입이 고정되어 있지 않고 할당되는 값에 따라 동적으로 결정됨 기본형: number, string, boolean, null, undefined 파생형: object (배열, 함수 포함) 함수의 typeof 결과는 \u0026lsquo;function\u0026rsquo;으로 특별 취급 타입 확인: typeof 연산자 사용 호이스팅(Hoisting) 변수/함수 선언이 범위의 최상단으로 끌어올려지는 현상 함수 선언: 선언 전에 호출 가능 var 변수: 선언 전에 접근하면 undefined 스코프(Scope) 전역 변수: 함수 외부에서 선언, window 객체의 속성 지역 변수: 함수 내부에서 var로 선언, 함수 내에서만 유효 ES5 기준: 블록({}) 단위 스코프 X 2. 객체와 프로토타입(Object \u0026amp; Prototype) 객체 생성 객체 리터럴: {}로 생성, 속성과 메서드 추가 가능 생성자 함수: function Person(...), new 키워드로 객체 생성 this 키워드 함수를 호출한 객체를 가리킴(사용 위치에 따라 다름) 전역: window 객체 메서드 내: 해당 객체 생성자 함수 내: 생성될 객체 call(), apply()로 this 명시적 변경 가능 프로토타입(Prototype) JS 상속의 핵심 메커니즘 모든 객체는 생성자 함수의 prototype 객체를 가리키는 내부 링크(__proto__)를 가짐 생성자.prototype에 메서드를 추가 → 해당 생성자로 만들어진 모든 객체가 공유함(메모리 효율↑) 3. DOM(Document Object Model) 조작 DOM이란? 브라우저가 HTML 문서를 읽어 트리 구조의 객체로 메모리에 생성한 것 JS는 DOM을 통해 HTML 요소에 접근·조작 가능 요소 선택 document.getElementById('id') : id로 요소 선택(단일) document.querySelectorAll('selector') : CSS 선택자로 요소들 선택(복수) 요소 조작 및 추가 element.innerHTML : 요소 내부 HTML 변경 element.style.color : CSS 스타일 변경 document.createElement('tag') : 새 요소 생성 parentElement.appendChild(childElement) : 자식 요소를 부모에 추가 4. 이벤트(Event) 처리 기본 개념 이벤트: HTML 요소에서 발생하는 클릭, 마우스 오버 등의 사건 이벤트 핸들러: 이벤트 발생 시 실행할 함수 이벤트 모델 기본: element.onclick = function() { ... } 표준: element.addEventListener('click', handler) 여러 이벤트 핸들러 등록 가능 이벤트 전파(Event Propagation) 이벤트 버블링: 자식 요소에서 발생한 이벤트가 부모 요소로 올라가며 전파되는 현상 ","date":"2025-08-24T00:00:00Z","permalink":"http://localhost:1313/posts/week10-2-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 10주차(2)"},{"content":" 10주차 학습 정리 - 1 이번 주 키워드 Spring DI \u0026amp; AOP Spring MVC 동작 원리 DAO, DTO, Service 계층 분리 MyBatis SQL 매핑 트랜잭션(Transaction) 처리 1. Spring의 핵심 철학: DI와 AOP 의존성 주입 (DI, Dependency Injection) IoC (제어의 역전): 객체의 생성과 생명주기를 개발자가 아닌 스프링 컨테이너(ApplicationContext)가 관리하는 개념 Bean (빈): 스프링 컨테이너가 관리하는 자바 객체(POJO) DI (의존성 주입): 필요한 객체를 직접 생성하지 않고 외부(스프링 컨테이너)에서 주입받는 방식 @Autowired: 타입을 기준으로 빈을 찾아 자동으로 의존성을 주입 @Resource: 이름을 기준으로 빈을 찾아 자동으로 의존성을 주입 @Component: 클래스를 스캔하여 빈으로 자동 등록 관점 지향 프로그래밍 (AOP, Aspect Oriented Programming) AOP: 트랜잭션, 로깅, 보안 등 여러 메서드에 공통적으로 필요한 **부가 기능(횡단 관심사)**을 핵심 비즈니스 로직에서 분리하는 기술 주요 용어: Advice: 부가 기능 자체(코드). Join point: Advice가 적용될 수 있는 위치 (예: 메서드) Pointcut: Advice를 실제로 적용할 Join point를 선별하는 패턴 Weaving: Advice를 핵심 로직에 적용하여 프록시(Proxy) 객체를 만드는 과정 2. Spring MVC 아키텍처 심화 DispatcherServlet: 모든 클라이언트의 요청을 가장 먼저 받아 처리 흐름을 제어하는 중앙 컨트롤러 요청 처리 흐름: 요청 → DispatcherServlet HandlerMapping이 요청 URL에 맞는 Controller 탐색. HandlerAdapter가 Controller의 메서드를 호출 Controller는 비즈니스 로직 처리 후, View 이름과 Model을 반환 ViewResolver가 View 이름을 기반으로 실제 View(JSP 등)를 찾아 렌더링 상태 관리: 쿠키 vs 세션 쿠키(Cookie): 사용자의 정보를 **브라우저(클라이언트)**에 저장하는 작은 데이터 조각 세션(Session): 사용자의 정보를 서버에 저장하고, JSESSIONID 쿠키를 통해 클라이언트를 식별하는 방식 예외 처리 @ExceptionHandler: 컨트롤러 내에서 특정 예외를 처리하는 메서드를 지정 @ControllerAdvice: 여러 컨트롤러에 걸쳐 발생하는 예외를 전역적으로 처리 3. 데이터베이스 연동과 계층형 아키텍처 계층 분리(Layering): 유지보수성과 재사용성을 높이기 위해 코드를 Controller - Service - Repository(DAO) 계층으로 분리 Controller: HTTP 요청/응답 처리 Service: 비즈니스 로직 및 트랜잭션 처리 Repository(DAO): 순수 데이터베이스 접근(CRUD) 담당 DTO (Data Transfer Object): 계층 간 데이터 전송을 위해 사용되는 객체 MyBatis 연동 MyBatis: SQL 쿼리를 Java 코드에서 분리하여 XML 파일(Mapper)로 관리하는 SQL 매핑 프레임워크 SqlSession: SQL 실행에 필요한 메서드(insert, selectOne 등)를 제공하는 핵심 객체 동적 쿼리: \u0026lt;if\u0026gt;, \u0026lt;choose\u0026gt;, \u0026lt;foreach\u0026gt; 등의 태그를 사용해 조건에 따라 SQL을 동적으로 생성 가능. 검색 기능 구현 시 매우 유용 4. 트랜잭션 관리와 REST API 트랜잭션 (Transaction) 정의: \u0026lsquo;모 아니면 도\u0026rsquo;처럼, 모두 성공하거나 모두 실패해야 하는 분리될 수 없는 하나의 작업 단위 ACID 속성: 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 영속성(Durability)을 보장 Spring의 트랜잭션 처리: @Transactional 어노테이션을 서비스 계층 메서드에 추가하면, AOP를 통해 트랜잭션의 시작, 커밋, 롤백이 자동으로 관리됨 REST API와 Ajax REST API: 자원(Resource)을 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)로 해당 자원에 대한 행위를 정의하는 아키텍처 스타일 Ajax: 웹 페이지 전체를 새로고침하지 않고, 백그라운드에서 서버와 데이터를 교환하여 화면 일부만 동적으로 갱신하는 기술 @RestController: @Controller와 @ResponseBody를 합친 것으로, 메서드의 반환 값을 View가 아닌 JSON 등의 데이터 형식으로 반환할 때 사용 마무리 스프링 프레임워크를 적용하게 되면 단순히 코드를 분리하는 것을 넘어, 각 계층의 책임이 명확해지고,\n@Transactional 어노테이션 하나로 서비스 계층의 비즈니스 로직 전체를 원자적 단위로 묶어 처리할 수 있다는 점이\n인상 깊었다.\n또한 MyBatis를 통해 SQL 쿼리를 자바 코드와 완전히 분리하면서, 왜 SQL 매퍼 프레임워크가 필요한지를 체감했다.\n자바 코드에서는 비즈니스 로직에만 집중하고, SQL은 XML에서 따로 관리하니 가독성과 유지보수성이 크게 향상되었다. DI, AOP, 트랜잭션, 계층형 아키텍처 등의 개념들이 스프링이라는 생태계 안에서 어떻게 유기적으로 결합하여 동작하는지를 깨닫게 된 한 주였다.\n앞으로는 단순히 기능을 구현하는 것을 넘어, 스프링의 철학을 이해하고 각 기술이 어떤 문제를 해결하기 위해 등장했는지 고민하며 코드를 작성해야겠다고 다짐했다.\n","date":"2025-08-23T00:00:00Z","permalink":"http://localhost:1313/posts/week10-1-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 10주차(1)"},{"content":" 9주차 학습 정리 이번 주 키워드 웹(Web)의 구조와 표준 HTTP 프로토콜 Spring MVC 구조 서블릿/ JSP 동작 원리 1. 웹(Web) 기초 웹(Web)과 인터넷(Internet) 웹: 리소스들을 거미줄처럼 연결한 것 인터넷: 웹이 동작하기 위한 인프라 리소스(Resource) 정적 리소스: text, 이미지, 오디오, 비디오 동적 리소스: streaming, 웹 애플리케이션 웹 표준과 접근성 웹 표준: W3C 재단에서 제정, 현재 HTML5.1(2016) 웹 접근성: 장애에 구애받지 않고 누구나 이용 가능하게 HTML Hyper Text Markup Language 문서 내 단어나 데이터베이스와 링크 → 사용자가 원하는 정보 탐색 가능 2. 스프링(Spring) 개요 Spring Framework (레거시) → 기존 방식 Spring Boot → 사용 권장 (설정 간소화) 외부 접근 내 프로그램(서버)을 외부 클라이언트가 URL로 사용 가능 @Controller : 프로그램 등록 @RequestMapping : URL과 메서드 연결\n→ 특정 URL 요청 시 해당 메서드 실행 3. HTTP 요청과 응답 요청(Request) : HttpServletRequest로 들어옴 (정보를 객체화) requestUrl: 리소스 요청 queryString: 추가 정보 (Map 구조) 응답(Response) : text(HTML, CSS, JS) 또는 binary(file, image 등) 클라이언트-서버 구조 웹 요청을 처리하는 서버 = 웹 서버 (예: Apache) 웹 애플리케이션 실행 = WAS(Web Application Server, 예: Tomcat) 하나의 프로그램이 여러 서버를 가질 경우 → 포트 번호 구분 4. Tomcat 서버 구조 WAS = 서비스(커넥터 + 엔진[카탈리나]) 내부 구조는 Map 기반의 컨테이너 (캐싱으로 성능↑)\n→ FlyWeight 패턴 적용 (객체/자원 재사용 극대화) 메모리 성능 영향을 주는 요소 클래스 수 (적을 수록 좋음) 객체 재사용성 동적 할당 최소화 5. HTTP 프로토콜 정의: Hyper Text Transfer Protocol (텍스트 기반) 특징 stateless: 클라이언트 상태 저장 X connectless: 요청-응답 후 연결 종료 HTTP 상태 코드 100번대 : Informational 200번대 : Success 300번대 : Redirect 400번대 : Client Error 500번대 : Server Error HTTP 메서드 HEAD, GET(소용량 조회), POST(대용량 쓰기), PUT(업로드), DELETE, PATCH(수정), TRACE, OPTIONS 보안 HTTP는 암호화가 없음 → TLS 기반 HTTPS 사용 권장 MIME \u0026amp; Base64 MIME: text 기반 프로토콜에서 binary 전송 시 데이터 타입 명시 (Content-Type 헤더) Base64: binary → text 변환 (64진법 사용, 2^6) 6. Spring MVC 아키텍처 관심사의 분리(SoC): Controller → 데이터 처리 View → 출력 MVC 패턴 요청 → DispatcherServlet → 입력 처리 및 모델 생성 전달 → Controller에서 처리, 반환값은 View에서 렌더링 후 응답 컨트롤러 메서드 반환 타입 String : 뷰 이름 반환 void : 매핑된 url 끝 단어 == 뷰 이름 ModelAndView : Model과 View 함께 반환 7. 서블릿(Servlet) vs 컨트롤러 서블릿: 1클래스 = 1 URL\n컨트롤러: 1클래스 = 다수 URL\n→ URL 많아질수록 서블릿은 클래스 수도 증가\n서블릿 호출 과정: JSP → .jsp → .java(서블릿) → .class 컴파일 → 인스턴스 생성 후 응답\nJSP : HTML 속 Java (``),\n서블릿 : Java 속 HTML (out.print(\u0026quot;\u0026quot;))\nJSP Scope 전역: application (프로그램 전체 1개) 지역: method 영역 세션: 사용자별 객체 (Login~Logout 동안 유지) 요청: Request 범위 +) 파이썬/자바스크립트도 각 Scope를 Map 구조로 관리\n8. JSP \u0026amp; 스프링 연동 요소 URL 패턴\n정확히 일치, 경로 일치, 확장자 일치, 기본값 예: JspServlet =\u0026gt; *.jsp, DispatcherServlet =\u0026gt; /* JSTL / EL 태그\n\u0026lt;% %\u0026gt; → JSTL로 대체 (Java 코드 제거) \u0026lt;%= 값%\u0026gt; → EL 태그로 대체 @RequestParam\n요청 파라미터를 메서드 매개변수로 바인딩 @ModelAttribute\n파라미터를 Model 속성으로 자동 추가 반환 타입/메서드 매개변수에 적용 가능 마무리 JSP와 Servlet으로 게시판 사이트를 따라 만들어본 경험은 있었지만, 이번에 동작 원리를 심도 있게 배우면서 예전엔 복잡하게만 느껴졌던 코드들이 훨씬 잘 이해되기 시작했다. 특히 Spring Framework로 실습을 오랜만에 해보면서 Spring Framework와 Spring Boot의 차이점을 명확히 짚고 넘어갈 수 있었던 점이 의미있었다. 이전에는 단순히 \u0026ldquo;Spring Boot로 만들면 편하다\u0026quot;는 정도로만 생각했는데,\n내장 톰캣 지원뿐 아니라, 자동 설정, 스타터(Starter) 의존성 관리, 쉬운 환경구성 등 다양한 차이점이 있음을 체감할 수 있었다.\nSpring Boot가 얼마나 개발자의 불필요한 반복 작업과 초기 설정을 줄여주는지를 구체적으로 알게 되어, \u0026ldquo;왜 현업에서 표준처럼 쓰이는지\u0026quot;도 납득이 갔다.\n프레임워크란 결국 개발자의 편의를 높이기 위해 등장한 것이지만,\n그 원리와 기초 기술을 제대로 이해하고 활용하는 것과 단순히 겉만 사용하는 것에는 분명 큰 차이가 있다는 사실을 다시 깨달았다.\n앞으로는 편리함에만 기대지 않고, 동작 원리와 내부 구조까지 깊이 이해하며 기술을 활용하는 습관을 가져야겠다고 다짐했다. ","date":"2025-08-17T00:00:00Z","permalink":"http://localhost:1313/posts/week9-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 9주차"},{"content":" 이펙티브 자바 1. 생성자 대신 정적 팩터리 메서드를 고려하라 장점 이름 부여: 반환 목적, 특징을 이름에 반영 가능 (of(), valueOf(), from() 등) 인스턴스 재사용: 반드시 새 객체가 필요하지 않다면 캐시·싱글턴 등으로 같은 객체를 재사용할 수 있음 (성능·메모리 절약, ex. Boolean.valueOf, Integer.valueOf) 인스턴스 통제: 싱글턴, 불변 값 객체, 인스턴스화 불가능 객체(팩터리 메서드만 제공) 등 다양한 객체 관리 전략을 구현하기 쉬움 반환 타입 유연성: 팩터리 메서드의 반환타입은 하위타입까지 포함할 수 있어 확장성이 높음 (ex. 인터페이스 반환, 다양한 구현체 숨김) 구현 클래스 은닉: API 바깥에 구체 구현 클래스를 노출하지 않고도 객체를 반환할 수 있음 (ex. 컬렉션 프레임워크의 List.of 등) 다양한 반환: 입력값에 따라 서로 다른 클래스의 객체를 반환할 수 있음 단점 상속 제약: public/protected 생성자가 없으므로 하위 클래스를 만들 수 없음 (확장 불가) 호출 가시성↓: 사용자가 ‘생성자’로 객체를 찾는 습성 때문에, 정적 팩터리 메서드의 존재가 눈에 덜 띌 수 있음 2. 생성자에 매개변수가 많다면 빌더 패턴을 고려하라 점층적 생성자 패턴은 매개변수가 많아지면 난해 자바빈즈 패턴(setter)은 객체 일관성 깨짐 위험 빌더 패턴: 필수 매개변수는 생성자/정적 메서드, 선택 매개변수는 빌더 메서드 체이닝, 마지막에 build() MyObj obj = MyObj.builder(\u0026#34;필수1\u0026#34;, \u0026#34;필수2\u0026#34;) .optionA(123) .optionB(\u0026#34;abc\u0026#34;) .build(); 3. 싱글턴을 보증하는 방법 private 생성자 + public static final 필드 public class Singleton { public static final Singleton INSTANCE = new Singleton(); private Singleton() {} } private 생성자 + public static 팩터리 public class Singleton { private static final Singleton INSTANCE = new Singleton(); private Singleton() {} public static Singleton getInstance() { return INSTANCE; } } enum 사용 (가장 안전) public enum Singleton { INSTANCE; } 4. 인스턴스 생성을 막고 싶다면 private 생성자를 사용 추상클래스만으로는 인스턴스 생성 차단 불가 반드시 private 생성자 명시 유틸리티 클래스(정적 메서드만 모은 클래스)에서 사용 5. 의존 객체 주입(Dependency Injection) 활용 자원 변경이 필요한 경우 정적 유틸리티/싱글턴은 부적합 생성자 / 세터 / 인터페이스 / 람다 / 팩터리 등으로 주입 Mock 객체나 대체 구현체로 테스트 용이성 확보 6. 불필요한 객체 생성 피하기 불변 객체·캐시 재사용 값 비교시 == 사용 박싱/오토박싱 주의 7. 다 쓴 객체 참조 해제: 메모리 누수 예방 직접 메모리 관리 클래스(컬렉션, 캐시 등): 사용 후 참조 해제(null, 삭제 등) WeakHashMap, LinkedHashMap, java.lang.ref 활용 가능 참조변수를 유효 범위 밖으로 밀어내기 8. 결합도와 객체 생성 방식 비교 방식 결합도 확장/유연성 테스트 용이성 대표 사례 직접 생성 강함(Tight) 낮음 어려움 new MyObj(...) 팩토리 패턴 느슨함(Loose) 높음 좋음 new MyObj(factory) 람다/함수식 주입 매우 느슨함 매우 높음 매우 좋음 Java 8+ Supplier 등 9. equals와 hashCode 논리적 동치 비교 필요 시 규약 준수하여 재정의 필수 hashCode 불일치 시 HashSet/HashMap 등에서 문제 발생 10. 클래스와 멤버 접근 권한 최소화 public 가변 필드 → Thread-Safety 문제 내부 구현 최대한 은닉, API 최소 공개 디자인 패턴 객체 재사용 패턴 패턴 목적 특징/주요 역할 Singleton 객체 1개만 생성·재사용 전역 인스턴스, 상태 공유 Flyweight 객체 여러 개를 공유해 재사용 메모리 절약, 상태 최소화 Prototype 객체 복제(Cloning) clone/factory 기반 효율적 생성 Builder 복잡한 객체 생성 선택·필수 매개변수 분리, 조립식 생성 Iterator 컬렉션 순회 책임 분리 내부 구조 노출 없이 순회 행위 \u0026amp; 구조 분리 패턴 Template Method 추상클래스에서 알고리즘 구조를 정의, 하위클래스가 세부 구현 예: AbstractList, AbstractCollection Strategy 알고리즘을 객체로 분리, 런타임에 주입 예: Comparator, Collections.sort Bridge 구현부와 추상부를 분리해 독립 확장 가능 예: JDBC Driver 구조 생성/구조/행위 패턴 패턴 개념/역할 설명·예시 Factory Method 객체 생성 추상화 Creator/Factory가 Product 생성 위임 Abstract Factory 객체 집합 생성 팩터리 테마별/계열별 제품군 생성, 의존성 교체 용이 Adapter 인터페이스 변환, 호환성 유지 구버전 → 신버전 연결 Proxy 대리자 역할, 접근 제어 Spring AOP, Lazy Loading Composite 트리 구조, 전체-부분 계층 폴더-파일 구조, UI 구성 Command 요청 캡슐화 실행/취소/이력 관리, Runnable, ActionListener Observer 이벤트 알림 MVC 패턴, 이벤트 구독자 State 상태에 따라 행위 변경 TCP 연결 상태, 게임 캐릭터 상태 등 자료구조 개념 동일 타입 데이터를 일정 구조로 저장 탐색·삽입·삭제 등 연산 효율 극대화 주요 종류 1. 리스트와 배열 선형 저장, 탐색 O(n), 삽입/삭제 O(n) 2. 스택과 큐 스택: LIFO 큐: FIFO 3. 트리 이진 트리 순회: 전위(NLR), 중위(LNR), 후위(LRN), 레벨 순회 스레드 이진 트리\nNULL 포인터 → 중위 순회 이웃 노드 연결 재귀/스택 없이 반복문 가능 4. 서로소 집합 find(x): 대표 원소 탐색(경로 압축) union(x,y): 두 집합 합치기(랭크 병합) 5. 해시 테이블 해싱: 키 → 인덱스 충돌 해결 개방 주소법(선형, 이차, 랜덤, 이중 해싱) 체이닝(리스트, 트리 연결) 6. 우선순위 큐 높은 우선순위 데이터 먼저 처리 보통 힙(Binary Heap)으로 구현 7. 정렬 삽입·선택·퀵·병합 등 데이터 특성과 조건에 맞게 선택 ","date":"2025-08-10T00:00:00Z","permalink":"http://localhost:1313/posts/week8-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 8주차"},{"content":"이번 주 키워드 데이터 모델링 SQL 튜닝 및 인덱스 최적화 데이터 모델링 이론 모델(Model): 실제(업무)를 추상화해 만든 가상 구조. 모델링(Modeling): 현실(비즈니스) 분석 → 데이터로 표현할 수 있도록 구조화. 목적: 실제 업무를 효율적으로 시스템에 반영·지원하기 위함. 모델링 단계: 개념 모델: 핵심 엔티티·주제영역 도출, 전체 구조 파악 (AS-IS/TO-BE) 논리 모델: 명확하고 구체적인 규칙·관계/제약 설정 (정규화) 물리 모델: 실제 DB에 적합한 구조(컬럼타입/파티션/인덱스) 설계 데이터 모델의 주요 용어 용어 설명 엔티티 관리 대상이 되는 데이터 집합 (예: 고객, 주문) 속성 엔티티의 구체적 성질(예: 이름, 이메일) 식별자 유일하게 엔티티 구분 (Primary Key) 도메인 속성의 데이터 타입 및 허용값 범위 관계 엔티티 간 연결 (1:1, 1:N, M:N 등) ERD 엔티티 관계를 시각적으로 표현 (ER 다이어그램) 일반화/특수화: 상하위 엔티티 추상화(클래스 상속 비슷) 자기참조/재귀관계: 엔티티가 자기 자신과 관계를 가질 때 (예: 사원-상사) 관계형 데이터 모델 스키마: 테이블 구조(릴레이션명+컬럼명 등) 튜플: 테이블의 한 행(데이터 한 건) 제약조건 키 제약조건: Primary Key, Unique 등 실체 무결성: PK는 Null 불가 영역 무결성(Domain Integrity): 지정한 도메인 범위 값만 허용 함수 종속(함수적 종속성) 어떤 칼럼 값이 결정되면 나머지가 정해지는 관계(예: 학번 → 이름) 완전/부분/이행적 함수 종속; 완전 함수 종속만 남도록 테이블을 쪼개는 것 = 정규화 데이터 모델링 실습 개념 모델링: 업무 분석 → 주제영역·핵심 엔티티 도출, 엔티티 관계 설계\n논리 모델링: 엔티티/속성/관계 상세화, 도메인·제약조건 명확히 정의\n물리 모델링: 실제 DB에 맞게 타입/인덱스/파티션 설계\n엔티티 명명: 전체에서 유일하게, 쉽게 이해되는 이름\n식별자 설계: 유일하고 불변, 최소구성, Not Null(본질/인조 식별자)\n표준화 및 모델 품질 관리 데이터 항목·도메인·코드 표준화(만들어진 도메인 사전 활용) 코드(공통 코드, 테이블별 관리) 표준화 SQL 튜닝 SQL 처리과정 사용자가 SQL 실행 → 옵티마이저가 실행계획 수립 SQL 캐싱(SGA: 공유메모리, 라이브러리 캐시) 소프트 파싱: 캐시에 동일 SQL 있으면 바로 실행 하드 파싱: 없으면 파싱부터 재실행 PreparedStatement: 파싱·실행분리, 캐시 활용/성능↑, 보안↑ 데이터 저장 및 I/O 구조 클러스터 팩터(Clustering Factor): 인덱스-테이블 레코드 간 물리적 근접도, 낮을수록 효율↑ 블록(Block): 최소 I/O 단위(8KB 등) 순차/랜덤 액세스: 대량조회(순차/풀스캔), 소량조회(랜덤/인덱스스캔) 논리적/물리적 I/O: 캐시에서 읽거나 디스크 직접읽기 인덱스 튜닝 인덱스는 소량 데이터/조건절 자주 조회시 효율↑ DML(Insert/Update/Delete)이 많으면 인덱스가 오히려 성능↓, 디스크 낭비 인덱스 스캔 방식: Range/Full/Unique/Skip Scan(조건/인덱스 특성에 따라) 컬럼 변형, OR/IN/NULL, 부정조건에서는 인덱스가 잘 안 쓰일 수 있음 인덱스 생성시 주요 컬럼·조건 부여 순서 고려 조인 및 서브쿼리/소트 튜닝 반정규화: 조인비용 줄이는 대신 중복 허용 조인 방식: NL(소량, 인덱스), 소트머지(정렬), 해시(대량/일회성) 서브쿼리 튜닝: 인라인뷰/중첩/스칼라 서브쿼리, Exists/Unnest/Pushing/캐싱 활용 소트튜닝: 메모리 소트 권장 Sort 오퍼레이션: Aggregate, Order By, Group By, Unique, Join, Window 등 되도록 소트 지양, 반드시 필요하면 Union All·Exists 적극 활용 마무리 실제 실무에서는 데이터베이스 설계가 다양한 측면에서 중요하다는 사실을 깊이 깨닫게 됐다.\n그동안 프로젝트를 하면서는 종종 빠르게 결과를 내려고 DB 구조 설계 단계를 대충 넘겼지만,\n이번에 모델링 이론과 튜닝 원리까지 제대로 익히고 나니, 기초적인 이해 위에 세워진 체계적이고 탄탄한 DB 설계야말로\n생산성과 유지보수를 효율적으로 하는 데 도움이 되고, 좋은 서비스를 만드는 핵심이 된다는 것을 분명히 실감할 수 있었다.\n실제로 데이터를 어떻게 저장하고, 어떤 관계로 연결하며, 미래의 확장성이나 성능까지 고려하는 설계가 초기에 이뤄져야만,\n개발이 순조롭고 나중에 발생할 수 있는 성능 저하나 장애도 미리 예방할 수 있을 것 같다.\n데이터 모델링과 설계의 중요성을 마음에 새기고, 튼튼하게 설계 기반을 다질 수 있도록 노력해야겠다.\n","date":"2025-08-03T00:00:00Z","permalink":"http://localhost:1313/posts/week7-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 7주차"},{"content":"이번 주 키워드 SQL 기초 함수와 서브쿼리 JOIN, PIVOT, RANK SQL 기초 SQL은 DB 서버에게 명령을 내리는 질의 언어 SQL*PLUS: Oracle에서 SQL/PLSQL 실행 환경 제공 PL/SQL: Oracle의 절차형 확장 언어(프로그램 로직 추가) 테이블의 구성요소 PK(Primary Key): Not Null + Unique, 테이블의 유일성 보장 FK(Foreign Key): 다른 테이블 PK를 참조, 무결성 유지 INDEX: 검색 속도 향상, 인덱스 사용 시 O(log n) DML (Data Manipulation Language) INSERT: 한 행 입력 UPDATE / DELETE: 한 번에 1~여러 행 데이터 수정/삭제 가능 SELECT: 산술식, computed column(연산 컬럼) 칼럼 연결: name || ' ' || title as \u0026quot;직원명\u0026quot; 중복 제거: SELECT DISTINCT WHERE 절: 범위/조건 지정, IN/LIKE/%, _ 등 패턴매칭 %: 0개 이상 문자, _: 1개 문자 함수 (Function) 문자형 함수: UPPER, LOWER, INITCAP, CONCAT, SUBSTR, LENGTH, LPAD/RPAD, LTRIM/RTRIM, TRANSLATE, REPLACE 숫자형 함수: ROUND, TRUNC, MOD, POWER, SQRT, SIGN, CHR 날짜형 함수: SYSDATE, LAST_DAY, MONTHS_BETWEEN, ADD_MONTHS, ROUND/TRUNC 날짜 단위 변환 함수: TO_CHAR, TO_NUMBER, TO_DATE 집계(그룹) 함수: COUNT, AVG, SUM, MIN, MAX, STDDEV, VARIANCE GROUP BY와 Subgroup GROUP BY 시 SELECT에 그룹 함수, 그룹 컬럼만 허용 WHERE → ROWNUM → ORDER BY 순서로 처리됨 그룹 세분화 가능: GROUP BY 여러 조건 지정 JOIN EQUIJOIN: 동등 조인 (PK=FK) NON-EQUIJOIN: 등급, 누적합 등 정확히 일치하지 않는 값끼리 조인 OUTER JOIN: 매칭되지 않아도 표시 (부서 없는 직원 등) SELF JOIN: 테이블 자체를 서로 연결(상사-사원) 집합 연산: UNION, UNION ALL, INTERSECT, MINUS SubQuery (서브쿼리) 쿼리 내부의 쿼리: 서브쿼리 → 메인쿼리 순으로 실행 WHERE, HAVING, 컬럼 등에 활용 단일 행/다중 행 비교 연산자 (=, IN, ANY, ALL, EXISTS 등) 인라인 뷰: FROM절에 서브쿼리 사용으로 효율적 검색 제약조건 (Constraint) 컬럼 레벨 / 테이블 레벨 모두 선언 가능 NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK 데이터의 무결성을 각 단계(입력, 수정, 삭제)에서 보장 트랜잭션과 딕셔너리 트랜잭션: SQL 문장 묶음, COMMIT/ROLLBACK 딕셔너리(데이터 사전): USER* / ALL* / DBA_ 등의 메타정보, V$(성능·락 정보), DICTIONARY 뷰 DDL, DCL DDL (Data Definition Language): 테이블 등 구조 생성·변경, 자동 커밋, 롤백 불가 DCL (Data Control Language): 권한(ROLE) 부여/회수 - GRANT, REVOKE 객체(Object) 시퀀스(Sequence): 자동 번호(Unique Number) 발생, 여러 객체에서 공유 가능 START WITH, NEXTVAL, CURRVAL 생성 후 ALTER로 일부 속성만 변경 가능, 값은 자동 유효성 검사 인덱스(Index): B*Tree 기반, PK/UNIQUE는 Unique Index 자동 생성 데이터 적고 조회 비율 높으면 효과적(10~15% 이하) 뷰(View): 복잡한 쿼리 결과를 간단히 재활용, 보안 및 접근 제한 시노님(Synonym): 다른 오브젝트에 별명 부여 프로그램 유닛: 프로시저, 함수, 트리거, 패키지 등 고급 SQL 기능 NVL: NULL → 다른 값 치환 DECODE: IF/ELSE처럼 조건에 따라 값 반환 CASE: 복잡한 조건 처리 가능 PIVOT: 행→열 전환(피벗 테이블 작성) ROLLUP/CUBE: 그룹별 합계(소계) 계산 RANK: 행별(그룹별) 순위 의사컬럼(Pseudo Column): ROWNUM(순번), ROWID(물리주소), 인덱스 사용 여부 등 트리거(Trigger) 테이블에 특정한 DML(INSERT/UPDATE/DELETE) 명령이 발생시 자동 실행 타이밍(BEFORE/AFTER), 범위(STATEMENT/ROW)로 구분 옵티마이저 SQL을 가장 효율적으로 실행하도록 실행계획(컴파일) 결정 마무리 이번 주 학습을 통해 DDL, DML 등 자주 사용하는 SQL 문법에만 익숙해진 나머지,\n실제로는 다양한 DB 개념들을 많이 잊고 있었다는 점을 다시 한 번 실감했다.\n프로젝트나 실무에서 데이터 조작과 테이블 구조 관리에만 신경 쓰다 보면,\nDB 설계나 튜닝에 있어서 정말 중요한 핵심 원리들이 뒷전으로 밀려나는 경우가 많은 것 같다.\n특히 좋은 DB 설계와 효율적인 성능 튜닝을 위해서는 단지 SQL 쿼리문만 잘 쓰는 것에서 한 걸음 더 나아가,\n제약조건이나 인덱스 구조, 트랜잭션 처리, 뷰·시퀀스 같은 객체의 특성과 역할을 확실히 이해하고 있어야 함을 느꼈다.\n이번 기회를 통해 오래된 개념들도 제대로 복습하고, 단편적인 쿼리 작성 실력만 키우는 게 아니라\n실무에 바로 적용 가능한 탄탄한 DB 설계 능력까지 함께 키워야겠다고 다짐했다.\n","date":"2025-07-27T00:00:00Z","permalink":"http://localhost:1313/posts/week6-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 6주차"},{"content":" 이번 주 키워드 쓰레드(Thread) 람다 스트림 쓰레드(Thread) 프로세스(Process): 실행 중인 프로그램 쓰레드(Thread): 프로세스 내에서 실제 작업을 수행하는 최소 단위 멀티쓰레딩: 하나의 프로세스에서 여러 쓰레드가 병렬로 작업, 효율성과 응답성 향상 멀티쓰레딩의 장점과 단점 장점 CPU 사용률 증가 자원 활용 효율적 사용자 응답성 증가 코드 모듈화, 관리 용이 단점 자원 공유 시 동기화 문제 교착상태(Deadlock) 위험 교착상태: 여러 쓰레드가 서로 필요한 자원을 점유하며 서로 대기, 작업이 중단된 상태\n쓰레드 구현 방식 1. Thread 클래스 상속 (Template Method Pattern) class MyThread extends Thread { public void run() { System.out.println(getName()); } } MyThread myThread = new MyThread(); 단점: 다른 클래스 상속 불가 2. Runnable 인터페이스 구현 (Strategy Pattern) class MyRunnable implements Runnable { public void run() { System.out.println(Thread.currentThread().getName()); } } Runnable r = new MyRunnable(); Thread t = new Thread(r); 장점: 코드 재사용성, 일관성 우수 쓰레드 실행 반드시 start() 호출 → 새로운 쓰레드 생성 run()만 호출 시 일반 메서드 실행 쓰레드 실행 제어 메서드 설명 sleep(long ms) 지정 시간만큼 쓰레드 일시정지 join() 지정 쓰레드 작업 완료까지 대기 interrupt() 일시정지 중인 쓰레드를 깨움 yield() CPU를 다른 동등 우선순위 쓰레드에게 양보 resume(), suspend(), stop()은 데드락 등 안전 이슈로 사용 불가(Deprecated)[3][5].\n쓰레드 상태 상태 설명 NEW 쓰레드 생성, 아직 start() 호출 전 RUNNABLE 실행 중 혹은 실행 대기 BLOCKED 락 획득 대기 중 WAITING 무한 대기 TIMED_WAITING 지정된 시간 대기 TERMINATED 실행 종료 쓰레드의 동기화 멀티쓰레드 환경에서 공유 자원 접근 시 데이터 일관성을 보장하기 위해 동기화 필요\n임계 영역 \u0026amp; 락(Lock) 임계 영역: 동시에 하나의 쓰레드만 실행할 수 있는 코드 영역 Lock: 객체에 대한 접근을 제한하여 데이터 일관성 보장 synchronized 메서드 전체 동기화 public synchronized void method() { ... } 블록 동기화 synchronized(참조변수) { ... } 객체별로 하나의 Lock 보유 가능한 한 임계 영역 최소화 (블록 단위) wait() / notify() wait(): 락을 반납하고 대기 notify()/notifyAll(): 대기 중인 쓰레드 깨움 Object 메서드이므로 동기화 블록/메서드 내에서만 사용 명시적 Lock과 Condition Lock 클래스: java.util.concurrent.locks ReentrantLock, ReentrantReadWriteLock, StampedLock 등 조건 변수(Condition): 선별적인 알림, 기아(starvation) 해소 lock.lock(); try { // 임계 영역 } finally { lock.unlock(); } 락은 수동 해제 필요(finally로 처리) volatile 변수의 값을 각 쓰레드 캐시에 저장하지 않고 항상 메모리에서 읽음 변수의 원자성만 보장, 동기화 대용 불가 fork \u0026amp; join 프레임워크 JDK7 도입, 작업을 작은 단위로 나눠 병렬 수행 RecursiveAction: 반환값 없음 RecursiveTask: 반환값 있음 작업 분할 → work stealing (작업 훔치기)로 부하 분산 가상 쓰레드(Virtual Thread) 적은 자원으로 수십~수천만 개 생성 가능 항상 데몬 쓰레드, 우선순위 고정(5) ThreadLocal 사용 주의, 풀링 금지 구분 플랫폼 쓰레드 가상 쓰레드 스케줄러 OS JDK 생성수 수십만 개 수천만 개 호출 스택 2MB (고정) 4KB 이상 (가변) 생성 시간 40us 0.4us 컨텍스트 스위칭 10us 1us 컨티뉴에이션, 스택 청크 기반으로 경량 동작 Executor \u0026amp; ExecutorService Executor 패턴 작업 실행 추상화 ThreadFactory 생성과 실행 분리, 객체 재사용에 유리 ExecutorService 다양한 쓰레드 풀 제공 SingleThreadExecutor: 하나의 쓰레드가 모든 작업 처리 newThreadPerTaskExecutor: 작업마다 플랫폼 쓰레드 생성(재사용 X) newVirtualThreadPerTaskExecutor: 작업마다 가상 쓰레드 생성(재사용 X) Future 비동기 작업 결과 조회/통제 객체 get(): 결과 반환(블록), cancel(): 작업 취소 CompletableFuture 여러 비동기 작업을 연결하거나 조합할 때 활용 람다와 스트림 (함수형 프로그래밍 맛보기) 람다식 익명 함수, 메서드를 간결히 표현 (매개변수) -\u0026gt; {실행문} 함수형 인터페이스 추상 메서드 1개만 선언 @FunctionalInterface로 컴파일러 안전성 확보 @FunctionalInterface interface MyFunction{ void myMethod(); } 스트림(Stream) 데이터 소스(컬렉션, 배열 등)를 복잡한 반복문 없이 다루는 방법 연산은 대부분 파이프라인 형태 스트림 특징 데이터 원본 불변 일회성 내부반복 중간/최종 연산 분리 스트림 연산 종류 중간 연산: filter, map, sorted 등 (0~여러 번) 최종 연산: forEach, reduce, collect 등 (0~1번) collect() vs reduce() collect() : 그룹별 집계·추출(분할, 그룹화) reduce() : 누적 합산 병렬 스트림 여러 CPU 코어 사용, 요소 순서 보장 X Optional null 안전하게 다루기 위한 컨테이너 null 반환 대신 Optional 객체 반환 참고사항:\n멀티쓰레딩/가상쓰레드 설계시 동기화·Deadlock 예방·디버깅 용이성 필수 고려 비동기, 동시성 제어시 ExecutorService·CompletableFuture 활용 함수형 코드 작성시 함수형 인터페이스와 람다 적극 활용 대량 데이터 처리시 Stream과 Optional 적극 활용 마무리 이번 주는 쓰레드, 동기화, 가상 쓰레드 같은 핵심 개념을 한 번에 완벽하게 이해하기가 쉽지 않았던 한 주였다.\n개념만 읽을 때는 헷갈리는 부분도 많았지만, 직접 다양한 예제 코드를 작성해보면서 조금씩 감을 잡아야겠다.\n또, 가상 쓰레드(virtual thread)나 ExecutorService, 람다와 스트림 같은 최신 트렌드까지 폭넓게 다루다 보니\n한 번에 다 흡수하긴 어렵다는 생각도 들었다.\n하지만 이런 내용이 최신 Java에서 왜 중요한지, 앞으로 개발하면서 어떻게 활용할 수 있을지 궁금해지는 계기가 되었다.\n앞으로는 각 개념별로 작은 예시를 직접 더 많이 만들어보고, 잘 정리해서 내 것으로 만들어야 할 것 같다.\n어렵고 멀게만 느껴졌던 동시성, 함수형 프로그래밍에도 점점 익숙해질 수 있도록 꾸준히 연습해야겠다.\n","date":"2025-07-20T00:00:00Z","permalink":"http://localhost:1313/posts/week5-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 5주차"},{"content":" 이번 주 키워드 컬렉션 프레임워크 모던 자바 기능 쓰레드 1. 컬렉션 프레임워크 컬렉션: 여러 객체(데이터)를 모아 놓은 것\n프레임워크: 표준화, 정형화된 체계적인 프로그래밍 방식\n핵심 인터페이스\nList: 순서 O, 중복 O Set: 순서 X, 중복 X Map: key-value 구조, 순서 X, 키 중복 X, 값 중복 O List 중복 허용, 저장 순서 유지 주요 메서드: get(int index), remove(int index), set(int index, Object obj) ArrayList\n저장 순서 유지, 중복 허용 remove 시 요소 이동 및 size 감소 장점: 데이터 읽기 속도 빠름(O(1)), 구조 간단 단점: 크기 변경 불가, 비순차적 추가/삭제 느림 LinkedList\n추가/삭제 빠름(연결만 변경) 순서 O, 중복 허용, 조회는 O(n) 단방향 → Double Linked List, Double Circular Linked List로 개선 결론\n순차적 추가/삭제: ArrayList \u0026gt; LinkedList 중간 데이터 추가/삭제: ArrayList LinkedList Stack \u0026amp; Queue\nStack: LIFO, 배열 적합, 객체 생성 가능 Queue: FIFO, LinkedList 적합, 구현체 필요 PriorityQueue\n우선순위 높은 요소부터 꺼냄 null 저장 불가, 내부적으로 힙 구조 사용 Deque\n양쪽 끝에 추가/삭제 가능 구현체: ArrayDeque, LinkedList 등 컬렉션 요소 접근 Iterator \u0026amp; Iterable\nIterator: 컬렉션 요소를 하나씩 접근\nIterable: Iterator 반환 메서드 정의\nMap은 keySet(), entrySet() 등으로 Set 형태로 변환 후 iterator 사용\nEnumeration: Iterator의 구버전\nListIterator: 양방향, List 구현체만 사용 가능\nArrays 유틸리티\n메서드 설명 copyOf(), copyOfRange() 배열 복사 fill(), setAll() 배열 채우기 sort(), binarySearch() 배열 정렬/검색 (정렬 후 검색해야 정확) toString(), equals(), compare(), mismatch() 배열 출력/비교/정렬/불일치 인덱스 반환 asList() 배열을 List로 변환 Comparator \u0026amp; Comparable\nComparable: 기본 정렬 기준(오름차순) public interface Comparable { int compareTo(T o); } Comparator: 별도 정렬 기준 제공(내림차순 등) public interface Comparator { int compare(T o1, T o2); boolean equals(Object obj); } Set HashSet\n중복 저장 불가, 저장 순서 없음 필요시 LinkedHashSet 사용 add() 시 hashCode(), equals()로 중복 판별 TreeSet\n이진 탐색 트리 구조, 중복 불가, 순서 없음 정렬/검색/범위검색에 성능 우수 Comparable 구현 or Comparator 제공 필요 In-Order 순회로 정렬 결과 얻음 Map HashMap\n(구버전: HashTable)\nHashing 기법(배열+LinkedList 장점) 저장 순서 없음(LinkedHashMap 필요시 사용) 키는 유일, 값 중복 가능, null 허용 TreeMap\n이진 검색 트리 구조, 검색/정렬에 적합 범위검색/정렬 필요시 사용 Properties\nString key-value 저장, Hashtable 상속 저장 순서 없음, Enumeration 사용 환경설정 파일 등에서 사용, 파일 입출력 지원 Collections 클래스 동기화 컬렉션: Collections.synchronizedXXX() 변경 불가 컬렉션: Collections.unmodifiableXXX() 한 종류 객체만 저장: Collections.checkedXXX() 싱글톤 컬렉션: Collections.singletonXXX() 2. 모던 자바 기능 제너릭스 (Generics)\n다양한 타입의 객체를 다루는 메서드/컬렉션에서 컴파일 시 타입 체크 타입 안정성, 형변환 생략 가능 선언 및 사용법\nBox appleBox = new Box(); Box fruitBox = new Box(); static 멤버에는 타입 변수 사용 불가 제너릭 배열 생성 불가(참조 변수 선언은 가능) JDK 7+에서는 생성자 타입 생략 가능: new ArrayList\u0026lt;\u0026gt;() 제한된 제너릭\nextends: 특정 타입의 자손만 허용 인터페이스도 extends, 다중 제한은 \u0026amp;로 구분 와일드카드\n\u0026lt;? extends T\u0026gt;: 상한 제한(자손만 허용) \u0026lt;? super T\u0026gt;: 하한 제한(조상만 허용) \u0026lt;?\u0026gt;: 제한 없음, \u0026lt;? extends Object\u0026gt; 와 동일 제너릭 메서드\n메서드의 선언부에 제너릭 타입이 선언된 메서드 반환타입 바로 앞에 선언 제너릭 클래스가 아닌 클래스에도 정의 가능 형변환과 타입 제거\n제너릭 ↔ 원시타입: 형변환 가능(경고 발생) 제너릭 타입 간 형변환 불가 컴파일 시 타입 체크 후 제너릭 정보 제거(타입 소거) 열거형 (Enum) 관련 상수를 편리하게 선언, 값 비교(==)와 타입 체크 모두 가능 객체 개수 제한(생성자 private) 선언 및 사용법\nenum Direction { EAST, SOUTH, WEST, NORTH } 비교: == 또는 compareTo() JDK 21+: switch문 조건식에 사용, 모든 case 처리 필요 주요 메서드\n메서드 설명 getDeclaringClass() 열거형의 Class 객체 반환 name() 상수 이름 반환 ordinal() 정의 순서(0부터) 반환 valueOf(Class, String) 이름으로 상수 반환 values() 모든 상수 배열 반환 멤버 추가\nenum Direction { EAST(1), SOUTH(5), WEST(-1), NORTH(10); private final int value; Direction(int value) { this.value = value; } public int getValue() { return value; } } 애너테이션 (Annotation) 프로그램에 메타데이터(부가 정보) 제공 표준 애너테이션\n@Override, @SuppressWarnings, @FunctionalInterface 메타 애너테이션\n@Target, @Retention, @Native Record (레코드) 불변 데이터 클래스를 간편하게 작성(JDK 16~) record Point(int x, int y) {} 모든 레코드는 java.lang.Record 상속(final, 다른 클래스 상속 불가) 내부 변수/초기화 블럭 추가 불가, 내부 레코드는 항상 static 실드 클래스 (Sealed Class) 상속 가능한 자식 클래스를 명시적으로 제한(JDK 17~) sealed class Shape permits Circle, Rectangle {} final class Circle extends Shape {} non-sealed class Rectangle extends Shape {} 자식은 final, sealed, non-sealed 중 하나여야 함 모듈 시스템 (Module System) 패키지의 상위 집합, JDK 9+ 도입 module-info.java로 모듈의 이름, 의존성, 공개 패키지 등 정의 module org.example.myModule { requires java.desktop; exports org.example.pkgA; } 모듈 이름은 전역적으로 유일해야 함 전이적 의존성(requires transitive) 지원 순환 의존성 금지 자동 모듈 \u0026amp; 이름 없는 모듈\n모듈 설명자 없는 jar → 자동 모듈 이름 없는 모듈은 모든 모듈에 의존, 모든 패키지 노출 3. 쓰레드 프로세스와 쓰레드\n프로세스: 실행 중인 프로그램(독립적 작업 단위) 쓰레드: 프로세스 내에서 실행되는 작업 흐름의 단위 구분 프로세스(Process) 쓰레드(Thread) 정의 실행 중인 프로그램(독립적 작업 단위) 프로세스 내 실행 흐름(작업 단위) 메모리 독립적(코드, 데이터, 힙, 스택 모두 별도) 코드/데이터/힙 공유, 스택만 독립 자원 자체 소유, 다른 프로세스와 공유 불가 같은 프로세스 내에서 자원 공유 통신 IPC 등 별도 방식 필요 간단(공유 변수 등) 오버헤드 크고 무거움 가볍고 빠름 안정성 하나 종료돼도 다른 프로세스 영향 없음 하나 오류 시 전체 프로세스 영향 가능 멀티태스킹 vs 멀티쓰레딩\n멀티태스킹: 여러 프로세스가 동시에 실행 멀티쓰레딩: 하나의 프로세스 내 여러 쓰레드가 동시에 작업 수행 장점\nCPU 사용률 및 자원 효율성 향상 사용자 응답성 향상 코드 분리로 간결해짐 단점\n자원 공유로 인한 동기화, 교착상태(Deadlock) 등 문제 발생 가능 쓰레드의 구현과 실행 구현 방법\nThread 클래스 상속\nclass MyThread extends Thread { public void run() { System.out.println(getName()); } } MyThread t = new MyThread(); t.start(); 단점: 다른 클래스 상속 불가 Runnable 인터페이스 구현\nclass MyRunnable implements Runnable { public void run() { System.out.println(Thread.currentThread().getName()); } } Thread t = new Thread(new MyRunnable()); t.start(); 장점: 재사용성, 코드 일관성, 다른 클래스 상속 가능 실행\n반드시 start() 호출 → 새로운 쓰레드가 생성되어 run() 실행 한 번 종료된 쓰레드는 재실행 불가(새 객체 필요) start()와 run()의 차이\nrun(): 단순 메서드 호출(새 쓰레드 생성 X) start(): 새로운 쓰레드 생성, 호출 스택 생성 후 run() 호출 실행 중인 사용자 쓰레드가 하나도 없으면 프로그램 종료\n싱글쓰레드와 멀티쓰레드\n싱글쓰레드: 한 작업이 끝난 후 다른 작업 시작 멀티쓰레드: 여러 작업을 번갈아가며 처리, 동시에 실행되는 것처럼 보임 병행(Concurrency) vs 병렬(Parallelism)\n병행: 여러 쓰레드가 여러 작업을 동시에 진행 병렬: 하나의 작업을 여러 쓰레드가 나눠서 처리 쓰레드의 우선순위\n1~10 범위의 priority 멤버변수로 우선순위 지정 높을수록 더 많은 작업 시간 할당 시각적/응답성 작업은 우선순위 높게 설정 우선순위는 부모 쓰레드로부터 상속 쓰레드 그룹\n관련 쓰레드를 그룹으로 관리 그룹 내 다른 그룹 포함 가능(계층 구조) 모든 쓰레드는 반드시 쓰레드 그룹에 포함 기본적으로 main 쓰레드 그룹의 하위 그룹 데몬 쓰레드\n보조 작업(예: 가비지 컬렉터) 담당 무한루프+조건문으로 대기하다가 작업 수행 데몬 쓰레드가 생성한 쓰레드도 자동으로 데몬 사용자 쓰레드가 모두 종료되면 데몬도 자동 종료 쓰레드 실행 제어\n메서드 설명 static void sleep() 지정 시간 동안 쓰레드 일시 정지 void join() 지정 시간 동안 쓰레드가 실행되도록 함 interrupt() 쓰레드 작업 취소(정지 요청, sleep/join 상태 깨움) static void yield() 실행 시간 양보, 실행 대기 상태로 전환 resume(), stop(), suspend()는 데드락 위험으로 deprecated\n쓰레드의 상태\n상태 설명 NEW 생성, start() 미호출 RUNNABLE 실행 중 또는 실행 가능 BLOCKED 동기화 블록에 의해 일시 정지(lock 대기) WAITING 실행 가능하지 않은 일시 정지(조건 대기 등) TIMED_WAITING 지정 시간 동안 일시 정지 TERMINATED 작업 종료 마무리 낯선 개념들이 많아서 아직 정리가 덜 된 것 같지만\n한 번에 이해하려는 게 오히려 욕심인 거 같기도\u0026hellip;?\n익숙해질 때까지 자주 들여다봐야 할 것 같다.\n","date":"2025-07-11T00:00:00Z","permalink":"http://localhost:1313/posts/week4-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 4주차"},{"content":" 이번 주 키워드 예외 처리, java.lang 패키지, 유용한 자바 클래스\n프로그램 오류와 예외 프로그램 오류란?\n프로그램 실행 중 오작동을 하거나 비정상적으로 종료되게 하는 원인 발생 시점에 따라 아래와 같이 구분됨\n컴파일 에러: 코드 작성 중 컴파일러가 잡아내는 문법 오류 런타임 에러: 실행 중 발생하는 오류 (예: 0으로 나누기, 배열 인덱스 초과) 논리적 에러: 실행은 되지만, 의도와 다르게 동작하는 오류 에러와 예외\n에러(Error): 프로그램 코드로 수습할 수 없는 심각한 오류 (예: OutOfMemoryError) 예외(Exception): 코드로 수습 가능한 비교적 덜 심각한 오류 실행 중 발생하는 에러와 예외는 모두 Throwable의 하위 클래스\nThrowable ├─ Error // 시스템 오류, 복구 불가 └─ Exception // 예외 상황, 복구 가능 ├─ RuntimeException (개발자 실수) └─ 기타 Exception (사용자 실수 등) 예외 처리 예외 처리란?\n프로그램 실행 중 발생할 수 있는 예기치 못한 예외에 대비한 코드를 작성하는 것 예외 발생으로 인한 프로그램의 갑작스런 종료를 막고 정상적인 실행 상태를 유지하기 위함\n예외 처리의 기본은 로깅 (에러가 발생했을 때 상태와 원인을 기록하여 추후 원인 분석 및 유지보수에 활용)\n예외 처리 방법\ntry-catch: 직접 예외를 처리 throws: 예외를 호출자에게 전달 예외 은폐: 예외를 일부러 무시(권장하지 않음) 예외 되던지기(rethrow): catch에서 예외를 다시 던짐 try-catch 기본 구조\ntry { // 예외가 발생할 수 있는 코드 } catch (ExceptionType e) { // 예외 처리 코드 } finally { // 항상 실행되는 코드 (리소스 반환 등) } 예시\npublic class Example { public static void main(String[] args) { int number = 100; int result = 0; for (int i = 0; i \u0026lt; 10; i++) { try { result = number / (int)(Math.random() * 10); System.out.println(result); } catch (ArithmeticException e) { System.out.println(\u0026#34;0\u0026#34;); } } } } multi-catch (Java 7+)\ntry { // ... } catch (IOException | SQLException e) { e.printStackTrace(); } 조상-자손 관계 예외는 묶을 수 없음 멀티 catch 블록 내에서는 공통 조상 타입의 멤버만 사용 가능 예외 발생시키기 (throw)\nthrow new Exception(\u0026#34;강제 예외 발생\u0026#34;); 예외의 종류\nChecked Exception: 컴파일러가 예외 처리를 강제 (예: IOException) Unchecked Exception: RuntimeException 및 그 자손, 컴파일러가 체크하지 않음 메서드에서 예외 선언 (throws)\npublic void readFile() throws IOException { // 파일 읽기 코드 } finally 블록\n예외 발생 여부와 관계없이 항상 실행 주로 리소스 반환, 파일 닫기 등에 사용 try-with-resources (Java 7+)\ntry (BufferedReader br = new BufferedReader(new FileReader(\u0026#34;file.txt\u0026#34;))) { // 파일 읽기 } catch(IOException e) { e.printStackTrace(); } AutoCloseable 구현 객체는 자동으로 close() 호출 예외 되던지기(rethrow)\ncatch 블록에서 예외를 다시 던져 호출자에게 전달 사용자 정의 예외\nException을 상속받아 직접 정의 가능 기존 예외로 충분하다면 가급적 표준 예외 사용 권장 예외 연결 (Chained Exception)\n예외를 더 큰 단위로 묶어 처리 가능 catch 블록을 단순화할 수 있음 java.lang 패키지 주요 클래스 Object 클래스 모든 자바 클래스의 최상위 조상 주요 메서드: equals(Object obj): 객체 내용 비교 (오버라이딩 가능) hashCode(): 해시코드 반환, 컬렉션에서 사용 clone(): 객체 복제 (Cloneable 구현 필요) getClass(): 클래스 정보 반환 String 클래스 Immutable: 한 번 생성되면 변경 불가 문자열 리터럴은 상수 풀에서 관리되어 같은 문자열은 같은 객체 참조 주요 메서드/특징\ntrim(): 아스키 공백만 제거 strip(): 유니코드 공백도 제거 join(), StringJoiner: 구분자를 넣어 문자열 결합 getBytes(String charsetName): 인코딩 변환 format(), formatted(): 형식화된 문자열 생성 valueOf(): 기본형 → String 변환 parse자료형(): String → 기본형 변환 StringBuffer와 StringBuilder\nStringBuffer: 스레드 안전, 동기화 지원 StringBuilder: 동기화 미지원, 더 빠름 equals() 오버라이딩 X → 내용 비교시 String으로 변환 후 비교 Math 클래스 산술 연산 보조 메서드 제공 (addExact, subtractExact 등) 오버플로우 체크 가능 StrictMath: 플랫폼에 상관없이 일관된 결과 보장 래퍼(Wrapper) 클래스 기본형 값을 객체로 다룰 때 사용 (Integer, Double, Boolean 등) 오토박싱/언박싱 지원 -128~127 범위는 캐시로 재사용 java.util 주요 클래스 클래스 용도 Objects null 체크, 객체 비교 등 유틸리티 메서드 제공 Random 난수 생성, seed 지정 가능 regex 정규 표현식 지원, 텍스트 검색 및 치환 Scanner 콘솔/파일 입력을 편리하게 받을 때 사용 StringTokenizer 문자열을 여러 구분자로 토큰화 (split과 차이) BigInteger 매우 큰 정수 연산 지원 BigDecimal 고정소수점 연산, 금융 계산 등 정밀한 소수점 연산에 사용 날짜와 시간 Java 8 이전: Date, Calendar 클래스 사용 (불변 객체 아님, 복잡함) Java 8 이후: java.time 패키지 도입 불변 객체, 명확한 API 제공 날짜, 시간, 기간, 포맷팅, 파싱 등 다양한 기능 지원 날짜/시간 계산의 기본\n시분초 → 초로 변환, 계산 후 다시 시분초로 변환 년월일 → 일로 변환, 계산 후 다시 년월일로 변환 마무리 이번 주에는 자바의 예외 처리와 java.lang, java.util 패키지의 주요 클래스를 집중적으로 학습했다.\n프로젝트를 진행할 때마다 시간에 쫓겨 예외 처리나 테스트 코드 작성에 소홀했던 경험이 많았는데,\n실무에서는 로깅과 예외 처리, 그리고 테스트 코드의 중요성을 다시 한 번 깨달았다.\n실제로 전 직장에서 개발팀에 로그를 요청해 업무에 활용한 경험이 있었고,\n이 과정에서 로그가 안정적이고 유지보수하기 쉬운 코드를 작성하는 데 큰 도움이 될 뿐만 아니라,\n서비스 운영 중 발생하는 문제를 신속하게 해결하는 데도 매우 유용하다는 점을 체감했다.\n이러한 경험을 바탕으로 앞으로는 기능 구현뿐만 아니라 예외 처리와 테스트 코드 작성에도 더욱 신경 써야겠다고 다짐했다.\n앞으로는 꼼꼼하게 예외 처리와 테스트 코드를 챙기는 습관을 들여\n더 신뢰받는 개발자가 되고자 한다. ","date":"2025-07-04T00:00:00Z","permalink":"http://localhost:1313/posts/week3-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 3주차"},{"content":" 이번 주 키워드 객체 지향 설계, 클래스, 생성자, 추상클래스, 인터페이스 객체 지향이란? 객체 지향(Object-Oriented Programming, OOP) 은 현실 세계를 컴퓨터 안에 구현하는 방식 즉, 우리가 보는 세상처럼 데이터와 그 데이터를 다루는 행위를 객체라는 단위로 묶어서 표현하는 것\n실제 세계 분석, 관찰 → 설계(클래스 작성) → 객체 생성 → 객체 사용\nOOP의 목적\n코드 재사용성을 높이고\n유지보수를 쉽게 하며\n변화에 유연하게 대응할 수 있도록 함\n객체지향의 4대 원칙 캡슐화(Encapsulation)\n데이터(변수)와 기능(메서드)을 하나로 묶고 외부에서 직접 접근하지 못하게 막음 → 내부 구현은 숨기고, 인터페이스만 노출 → 복잡도 감소, 유지보수 용이 상속(Inheritance)\n기존 클래스를 확장하여 새로운 클래스를 생성 가능 → 코드 중복을 줄이고 공통 로직을 한 곳에서 관리\n추상화(Abstraction)\n공통적인 성질만 뽑아서 일반화한 개념 → 불필요한 정보는 숨기고 중요한 정보만 표현 → 예: 동물 → 고양이/강아지 (공통 행동: 먹다, 자다)\n다형성(Polymorphism)\n하나의 참조변수로 여러 객체 다루기\n다형적 매개변수\n하나의 배열에 여러 객체 저장\n클래스 정의\n설계도 변수 + 메서드 사용자 정의 타입 클래스 간의 관계\n상속 관계 (is-a) 자식 클래스가 부모 클래스를 확장 → ex) Dog extends Animal\n* 자바는 단일 상속만 지원\n포함 관계 (has-a) 하나의 클래스가 다른 클래스를 필드로 가짐 → ex) Person has a Address\n변수의 종류\n선언된 위치에 따라\n클래스 영역: class variable, instance variable 메서드 영역: local variable 생성자 변수의 초기화\n초기화 순서는 cv → iv, 자동(기본값) → 간단(대입 =) → 복잡({} 블럭) 순\n조건\n이름이 클래스와 동일 반환타입 없음(void안씀) 다른 생성자 호출은 반드시 첫줄에서 다른 생성자 호출시 this() 사용 오버라이딩 vs 오버로딩 오버라이딩(Overriding) 상속받은 메서드를 재정의하는 것 → 선언부는 같고, 구현부만 다르게 → 접근제어자: 부모보다 좁으면 안됨 → 반환 타입, 매개변수 동일해야 함\n오버로딩(Overloading) 같은 이름의 메서드를 여러 개 정의하는 것 → 매개변수의 개수나 타입이 달라야 함\n→ 반환타입은 영향을 미치지 않음\nsuper 키워드 super\n부모 클래스의 멤버(필드, 메서드)를 참조할 때 사용\nsuper()\n부모 생성자를 호출할 때 사용\n생성자의 첫 줄에는 반드시 this() 또는 super() 중 하나가 있어야 하며,\n없으면 컴파일러가 super()를 자동 삽입함\n다형성과 형변환 부모 타입으로 자식 객체를 참조할 수 있음 → 확장성과 유연성 확보\n하지만 자식 타입으로 다시 형변환하려면 instanceof로 확인해야 함\nif (animal instanceof Dog) { Dog dog = (Dog) animal; dog.bark(); } 형변환을 통해 참조 변수(리모컨)를 바꿔 객체가 가진 메서드 범위를 조절\n추상 클래스 (abstract class) 미완성 설계도 → 객체 생성 불가\n공통 부분은 구현하고, 바뀌는 부분만 추상 메서드로 정의\n상속받은 클래스가 추상 메서드를 반드시 구현해야 함\n인터페이스 (interface) 모든 메서드는 public abstract, 모든 변수는 public static final\n→ 생략해도 컴파일러가 자동 추가\n→ interface의 메서드를 오버라이딩하면 public을 반드시 붙여야 함 다중 구현 가능\n서로 관계없는 클래스에도 공통 기능 강제 가능\n+) 추상클래스는 iv를 가질 수 있지만 인터페이스는 iv를 가질 수 없음\n+) JDK 1.8 이후\ndefault, static 메서드 추가 가능\n→ 기존 구현 클래스에 영향 주지 않기 위해 도입\n→ default 메서드는 오버라이딩 가능\ninterface Animal { void sound(); // 추상 메서드 default void sleep() { System.out.println(\u0026#34;Sleeping...\u0026#34;); } } 마무리 예전에 면접을 봤을 때 객체지향에 대한 질문을 받고 제대로 답변하지 못했던 적이 있었는데\n여러 번 반복을 하고 강사님께서 강조하신 부분을 외우려고 노력을 하고 나니\n이제 객체지향이 뭔지, 어떤 특징을 가지고 있는지 등에 대해 확실히 정리가 된 것 같다.\n욕심 부리지 않고 조금씩 이론적인 부분에 대해 정리하고 설명할 수 있는 능력을 길러야겠다! ","date":"2025-06-27T00:00:00Z","permalink":"http://localhost:1313/posts/week2-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 2주차"},{"content":" 이번 주 키워드 변수, 설계 변수란? 자바에서 변수는 타입 + 이름으로 구성\n이 변수를 통해 쓰기(= 연산자), 읽기(변수명) 등의 작업을 수행 가능\n변수를 사용하는 이유?\n→ 컴파일러가 코드를 분석하고 오류를 사전에 잡을 수 있도록 하기 위해서\n컴파일러는 다음과 같은 작업을 수행:\n문법 체크 최적화 번역 (.java → .class) 📌 즉, 코드가 완벽하지 않아도 컴파일러가 이를 어느 정도 보완해줌\n변수의 종류 자바의 변수는 크게 두 가지:\n기본형(primitive): 하나의 요소 참조형(reference): 여러 개의 요소(집합) 참조형은 0~n개의 요소를 담는 집합이며,\n이 집합을 만들기 위해서는 기준을 가지고 그룹화를 수행\n➡️ 이것이 바로 설계\n설계란? 관련 있는 것끼리 하나의 집합으로 묶고 집합들 간의 관계를 정의\n설계를 하면 좋은 점:\n복잡도가 낮아지고 관리가 쉬워지며 더 복잡한 프로그램을 구현할 수 있게 됨 연산 연산이란 데이터를 계산하는 것\n같은 타입끼리만 연산 가능 반드시 결과를 반환해야 함 연산자에서 중요한 3요소:\n우선순위 결합법칙 산술 변환 둘 중 큰 타입으로 자동 변환 int보다 작은 타입끼리 연산 시 → int로 변환 후 연산 연습문제 정리 long형 변수에 정수값 저장 시 L을 붙이지 않으면 기본적으로 int로 인식\n→ int 범위 초과 시 컴파일 에러 발생\n'+' 연산자는\n둘 다 숫자 → 덧셈 하나라도 String → 문자열 이어붙이기 char + char / char + 숫자 → int 반환 단, ++, -- 같은 증감 연산자는 형변환 없이 char로 반환\n자바는 C처럼 0 = false, 1 = true를 인정하지 않음\n→ boolean에는 반드시 true / false 를 사용해야 함\nchar는 요소형 → 반드시 문자를 지정해야 함\n→ '' (빈 문자 리터럴) 사용 불가\n자바에서의 var Java 10부터 도입된 문법으로, 로컬 변수의 타입을 컴파일러가 자동 추론\n(컴파일 타임에 정적으로 결정, 런타임에 동적으로 바뀌지 않음)\n적절한 상황에 사용하면 코드의 가독성과 간결성이 좋아짐\n1. 타입이 너무 길어서 코드가 지저분할 때 // before Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // after var map = new HashMap\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt;(); 2. 우측 표현식으로 타입이 분명히 드러날 때 var name = \u0026#34;Soyeon\u0026#34;; // String var count = 123; // int var list = List.of(1, 2); // List\u0026lt;Integer\u0026gt; 3. for-each 루프에서 반복 변수 for (var item : items) { System.out.println(item); } 📌 주의:\nvar는 명시적인 타입 지정이 아닌 추론이기 때문에, 복잡한 표현식에서는 오히려 가독성을 해칠 수 있음 클래스 필드, 메서드 매개변수, 리턴 타입에는 사용할 수 없음 (오직 로컬 변수에만 사용 가능) → 사람이 읽을 수 있을 만큼만 추론을 맡기고 그렇지 않으면 명시적으로 타입을 작성하자! 마무리 java 기초 부분은 어느 정도 안다고 생각했는데 연습문제를 풀어보니\n컴파일러가 있어서 아무 생각 없이 코드를 작성하던 부분이 많았다는 것을 느꼈다.\n예습 복습을 하면서 기초를 탄탄히 다져야겠다! ","date":"2025-06-23T00:00:00Z","permalink":"http://localhost:1313/posts/week1-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 1주차]"}]