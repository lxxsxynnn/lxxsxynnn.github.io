[{"content":" 이번 주 키워드 컬렉션 프레임워크 모던 자바 기능 쓰레드 1. 컬렉션 프레임워크 컬렉션: 여러 객체(데이터)를 모아 놓은 것\n프레임워크: 표준화, 정형화된 체계적인 프로그래밍 방식\n핵심 인터페이스 List: 순서 O, 중복 O Set: 순서 X, 중복 X Map: key-value 구조, 순서 X, 키 중복 X, 값 중복 O List 중복 허용, 저장 순서 유지 주요 메서드: get(int index), remove(int index), set(int index, Object obj) ArrayList 저장 순서 유지, 중복 허용 remove 시 요소 이동 및 size 감소 장점: 데이터 읽기 속도 빠름(O(1)), 구조 간단 단점: 크기 변경 불가, 비순차적 추가/삭제 느림 LinkedList 추가/삭제 빠름(연결만 변경) 순서 O, 중복 허용, 조회는 O(n) 단방향 → Double Linked List, Double Circular Linked List로 개선 결론 순차적 추가/삭제: ArrayList \u0026gt; LinkedList 중간 데이터 추가/삭제: ArrayList LinkedList Stack \u0026amp; Queue Stack: LIFO, 배열 적합, 객체 생성 가능 Queue: FIFO, LinkedList 적합, 구현체 필요 PriorityQueue 우선순위 높은 요소부터 꺼냄 null 저장 불가, 내부적으로 힙 구조 사용 Deque 양쪽 끝에 추가/삭제 가능 구현체: ArrayDeque, LinkedList 등 컬렉션 요소 접근 Iterator \u0026amp; Iterable Iterator: 컬렉션 요소를 하나씩 접근\nIterable: Iterator 반환 메서드 정의\nMap은 keySet(), entrySet() 등으로 Set 형태로 변환 후 iterator 사용\nEnumeration: Iterator의 구버전\nListIterator: 양방향, List 구현체만 사용 가능\nArrays 유틸리티 메서드 설명 copyOf(), copyOfRange() 배열 복사 fill(), setAll() 배열 채우기 sort(), binarySearch() 배열 정렬/검색 (정렬 후 검색해야 정확) toString(), equals(), compare(), mismatch() 배열 출력/비교/정렬/불일치 인덱스 반환 asList() 배열을 List로 변환 Comparator \u0026amp; Comparable Comparable: 기본 정렬 기준(오름차순) public interface Comparable { int compareTo(T o); } Comparator: 별도 정렬 기준 제공(내림차순 등) public interface Comparator { int compare(T o1, T o2); boolean equals(Object obj); } Set HashSet 중복 저장 불가, 저장 순서 없음 필요시 LinkedHashSet 사용 add() 시 hashCode(), equals()로 중복 판별 TreeSet 이진 탐색 트리 구조, 중복 불가, 순서 없음 정렬/검색/범위검색에 성능 우수 Comparable 구현 or Comparator 제공 필요 In-Order 순회로 정렬 결과 얻음 Map HashMap (구버전: HashTable)\nHashing 기법(배열+LinkedList 장점) 저장 순서 없음(LinkedHashMap 필요시 사용) 키는 유일, 값 중복 가능, null 허용 TreeMap 이진 검색 트리 구조, 검색/정렬에 적합 범위검색/정렬 필요시 사용 Properties String key-value 저장, Hashtable 상속 저장 순서 없음, Enumeration 사용 환경설정 파일 등에서 사용, 파일 입출력 지원 Collections 클래스 동기화 컬렉션: Collections.synchronizedList() 등 변경 불가 컬렉션: Collections.unmodifiableList() 등 한 종류 객체만 저장: Generics ``, Collections.checkedList() 등 싱글톤 컬렉션: Collections.singletonList() 등 2. 모던 자바 기능 제너릭스 (Generics) 다양한 타입의 객체를 다루는 메서드/컬렉션에서 컴파일 시 타입 체크 타입 안정성, 형변환 생략 가능 선언 및 사용법 Box appleBox = new Box(); Box fruitBox = new Box(); static 멤버에는 타입 변수 사용 불가 제너릭 배열 생성 불가(참조 변수 선언은 가능) JDK 7+에서는 생성자 타입 생략 가능: new ArrayList\u0026lt;\u0026gt;() 제한된 제너릭 ``: 특정 타입의 자손만 허용 인터페이스도 extends, 다중 제한은 \u0026amp;로 구분 와일드카드 ``: 상한 제한(자손만 허용) ``: 하한 제한(조상만 허용) ``: 제한 없음 제너릭 메서드 public void print(T item) { ... } 형변환과 타입 제거 제너릭 ↔ 원시타입: 형변환 가능(경고 발생) 제너릭 타입 간 형변환 불가 컴파일 시 타입 체크 후 제너릭 정보 제거(타입 소거) 열거형 (Enum) 관련 상수를 편리하게 선언, 값 비교(==)와 타입 체크 모두 가능 객체 개수 제한(생성자 private) 선언 및 사용법 enum Direction { EAST, SOUTH, WEST, NORTH } 비교: == 또는 compareTo() JDK 21+: switch문 조건식에 사용, 모든 case 처리 필요 주요 메서드 메서드 설명 getDeclaringClass() 열거형의 Class 객체 반환 name() 상수 이름 반환 ordinal() 정의 순서(0부터) 반환 valueOf(Class, String) 이름으로 상수 반환 values() 모든 상수 배열 반환 멤버 추가 enum Direction { EAST(1), SOUTH(5), WEST(-1), NORTH(10); private final int value; Direction(int value) { this.value = value; } public int getValue() { return value; } } 애너테이션 (Annotation) 프로그램에 메타데이터(부가 정보) 제공 표준 애너테이션 @Override, @SuppressWarnings, @FunctionalInterface 메타 애너테이션 @Target, @Retention, @Native Record (레코드) 불변 데이터 클래스를 간편하게 작성(JDK 16~) record Point(int x, int y) {} 모든 레코드는 java.lang.Record 상속(final, 다른 클래스 상속 불가) 내부 변수/초기화 블럭 추가 불가, 내부 레코드는 항상 static 실드 클래스 (Sealed Class) 상속 가능한 자식 클래스를 명시적으로 제한(JDK 17~) sealed class Shape permits Circle, Rectangle {} final class Circle extends Shape {} non-sealed class Rectangle extends Shape {} 자식은 final, sealed, non-sealed 중 하나여야 함 모듈 시스템 (Module System) 패키지의 상위 집합, JDK 9+ 도입 module-info.java로 모듈의 이름, 의존성, 공개 패키지 등 정의 module org.example.myModule { requires java.desktop; exports org.example.pkgA; } 모듈 이름은 전역적으로 유일해야 함 전이적 의존성(requires transitive) 지원 순환 의존성 금지 자동 모듈 \u0026amp; 이름 없는 모듈 모듈 설명자 없는 jar → 자동 모듈 이름 없는 모듈은 모든 모듈에 의존, 모든 패키지 노출 3. 쓰레드 프로세스와 쓰레드 프로세스: 실행 중인 프로그램(독립적 작업 단위) 쓰레드: 프로세스 내에서 실행되는 작업 흐름의 단위 구분 프로세스(Process) 쓰레드(Thread) 정의 실행 중인 프로그램(독립적 작업 단위) 프로세스 내 실행 흐름(작업 단위) 메모리 독립적(코드, 데이터, 힙, 스택 모두 별도) 코드/데이터/힙 공유, 스택만 독립 자원 자체 소유, 다른 프로세스와 공유 불가 같은 프로세스 내에서 자원 공유 통신 IPC 등 별도 방식 필요 간단(공유 변수 등) 오버헤드 크고 무거움 가볍고 빠름 안정성 하나 종료돼도 다른 프로세스 영향 없음 하나 오류 시 전체 프로세스 영향 가능 멀티태스킹 vs 멀티쓰레딩 멀티태스킹: 여러 프로세스가 동시에 실행 멀티쓰레딩: 하나의 프로세스 내 여러 쓰레드가 동시에 작업 수행 장점 CPU 사용률 및 자원 효율성 향상 사용자 응답성 향상 코드 분리로 간결해짐 단점 자원 공유로 인한 동기화, 교착상태(Deadlock) 등 문제 발생 가능 쓰레드의 구현과 실행 구현 방법 Thread 클래스 상속\nclass MyThread extends Thread { public void run() { System.out.println(getName()); } } MyThread t = new MyThread(); t.start(); 단점: 다른 클래스 상속 불가 Runnable 인터페이스 구현\nclass MyRunnable implements Runnable { public void run() { System.out.println(Thread.currentThread().getName()); } } Thread t = new Thread(new MyRunnable()); t.start(); 장점: 재사용성, 코드 일관성, 다른 클래스 상속 가능 실행 반드시 start() 호출 → 새로운 쓰레드가 생성되어 run() 실행 한 번 종료된 쓰레드는 재실행 불가(새 객체 필요) start()와 run()의 차이 run(): 단순 메서드 호출(새 쓰레드 생성 X) start(): 새로운 쓰레드 생성, 호출 스택 생성 후 run() 호출 실행 중인 사용자 쓰레드가 하나도 없으면 프로그램 종료\n싱글쓰레드와 멀티쓰레드 싱글쓰레드: 한 작업이 끝난 후 다른 작업 시작 멀티쓰레드: 여러 작업을 번갈아가며 처리, 동시에 실행되는 것처럼 보임 병행(Concurrency) vs 병렬(Parallelism) 병행: 여러 쓰레드가 여러 작업을 동시에 진행 병렬: 하나의 작업을 여러 쓰레드가 나눠서 처리 쓰레드의 우선순위 1~10 범위의 priority 멤버변수로 우선순위 지정 높을수록 더 많은 작업 시간 할당 시각적/응답성 작업은 우선순위 높게 설정 우선순위는 부모 쓰레드로부터 상속 쓰레드 그룹 관련 쓰레드를 그룹으로 관리 그룹 내 다른 그룹 포함 가능(계층 구조) 모든 쓰레드는 반드시 쓰레드 그룹에 포함 기본적으로 main 쓰레드 그룹의 하위 그룹 데몬 쓰레드 보조 작업(예: 가비지 컬렉터) 담당 무한루프+조건문으로 대기하다가 작업 수행 데몬 쓰레드가 생성한 쓰레드도 자동으로 데몬 사용자 쓰레드가 모두 종료되면 데몬도 자동 종료 쓰레드 실행 제어 메서드 설명 static void sleep() 지정 시간 동안 쓰레드 일시 정지 void join() 지정 시간 동안 쓰레드가 실행되도록 함 interrupt() 쓰레드 작업 취소(정지 요청, sleep/join 상태 깨움) static void yield() 실행 시간 양보, 실행 대기 상태로 전환 resume(), stop(), suspend()는 데드락 위험으로 deprecated\n쓰레드의 상태 상태 설명 NEW 생성, start() 미호출 RUNNABLE 실행 중 또는 실행 가능 BLOCKED 동기화 블록에 의해 일시 정지(lock 대기) WAITING 실행 가능하지 않은 일시 정지(조건 대기 등) TIMED_WAITING 지정 시간 동안 일시 정지 TERMINATED 작업 종료 마무리\n","date":"2025-07-11T00:00:00Z","permalink":"http://localhost:1313/posts/week4.retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 3주차"},{"content":" 이번 주 키워드 예외 처리, java.lang 패키지, 유용한 자바 클래스\n프로그램 오류와 예외 프로그램 오류란?\n프로그램 실행 중 오작동을 하거나 비정상적으로 종료되게 하는 원인 발생 시점에 따라 아래와 같이 구분됨\n컴파일 에러: 코드 작성 중 컴파일러가 잡아내는 문법 오류 런타임 에러: 실행 중 발생하는 오류 (예: 0으로 나누기, 배열 인덱스 초과) 논리적 에러: 실행은 되지만, 의도와 다르게 동작하는 오류 에러와 예외\n에러(Error): 프로그램 코드로 수습할 수 없는 심각한 오류 (예: OutOfMemoryError) 예외(Exception): 코드로 수습 가능한 비교적 덜 심각한 오류 실행 중 발생하는 에러와 예외는 모두 Throwable의 하위 클래스\nThrowable ├─ Error // 시스템 오류, 복구 불가 └─ Exception // 예외 상황, 복구 가능 ├─ RuntimeException (개발자 실수) └─ 기타 Exception (사용자 실수 등) 예외 처리 예외 처리란?\n프로그램 실행 중 발생할 수 있는 예기치 못한 예외에 대비한 코드를 작성하는 것 예외 발생으로 인한 프로그램의 갑작스런 종료를 막고 정상적인 실행 상태를 유지하기 위함\n예외 처리의 기본은 로깅 (에러가 발생했을 때 상태와 원인을 기록하여 추후 원인 분석 및 유지보수에 활용)\n예외 처리 방법\ntry-catch: 직접 예외를 처리 throws: 예외를 호출자에게 전달 예외 은폐: 예외를 일부러 무시(권장하지 않음) 예외 되던지기(rethrow): catch에서 예외를 다시 던짐 try-catch 기본 구조\ntry { // 예외가 발생할 수 있는 코드 } catch (ExceptionType e) { // 예외 처리 코드 } finally { // 항상 실행되는 코드 (리소스 반환 등) } 예시\npublic class Example { public static void main(String[] args) { int number = 100; int result = 0; for (int i = 0; i \u0026lt; 10; i++) { try { result = number / (int)(Math.random() * 10); System.out.println(result); } catch (ArithmeticException e) { System.out.println(\u0026#34;0\u0026#34;); } } } } multi-catch (Java 7+)\ntry { // ... } catch (IOException | SQLException e) { e.printStackTrace(); } 조상-자손 관계 예외는 묶을 수 없음 멀티 catch 블록 내에서는 공통 조상 타입의 멤버만 사용 가능 예외 발생시키기 (throw)\nthrow new Exception(\u0026#34;강제 예외 발생\u0026#34;); 예외의 종류\nChecked Exception: 컴파일러가 예외 처리를 강제 (예: IOException) Unchecked Exception: RuntimeException 및 그 자손, 컴파일러가 체크하지 않음 메서드에서 예외 선언 (throws)\npublic void readFile() throws IOException { // 파일 읽기 코드 } finally 블록\n예외 발생 여부와 관계없이 항상 실행 주로 리소스 반환, 파일 닫기 등에 사용 try-with-resources (Java 7+)\ntry (BufferedReader br = new BufferedReader(new FileReader(\u0026#34;file.txt\u0026#34;))) { // 파일 읽기 } catch(IOException e) { e.printStackTrace(); } AutoCloseable 구현 객체는 자동으로 close() 호출 예외 되던지기(rethrow)\ncatch 블록에서 예외를 다시 던져 호출자에게 전달 사용자 정의 예외\nException을 상속받아 직접 정의 가능 기존 예외로 충분하다면 가급적 표준 예외 사용 권장 예외 연결 (Chained Exception)\n예외를 더 큰 단위로 묶어 처리 가능 catch 블록을 단순화할 수 있음 java.lang 패키지 주요 클래스 Object 클래스 모든 자바 클래스의 최상위 조상 주요 메서드: equals(Object obj): 객체 내용 비교 (오버라이딩 가능) hashCode(): 해시코드 반환, 컬렉션에서 사용 clone(): 객체 복제 (Cloneable 구현 필요) getClass(): 클래스 정보 반환 String 클래스 Immutable: 한 번 생성되면 변경 불가 문자열 리터럴은 상수 풀에서 관리되어 같은 문자열은 같은 객체 참조 주요 메서드/특징\ntrim(): 아스키 공백만 제거 strip(): 유니코드 공백도 제거 join(), StringJoiner: 구분자를 넣어 문자열 결합 getBytes(String charsetName): 인코딩 변환 format(), formatted(): 형식화된 문자열 생성 valueOf(): 기본형 → String 변환 parse자료형(): String → 기본형 변환 StringBuffer와 StringBuilder\nStringBuffer: 스레드 안전, 동기화 지원 StringBuilder: 동기화 미지원, 더 빠름 equals() 오버라이딩 X → 내용 비교시 String으로 변환 후 비교 Math 클래스 산술 연산 보조 메서드 제공 (addExact, subtractExact 등) 오버플로우 체크 가능 StrictMath: 플랫폼에 상관없이 일관된 결과 보장 래퍼(Wrapper) 클래스 기본형 값을 객체로 다룰 때 사용 (Integer, Double, Boolean 등) 오토박싱/언박싱 지원 -128~127 범위는 캐시로 재사용 java.util 주요 클래스 클래스 용도 Objects null 체크, 객체 비교 등 유틸리티 메서드 제공 Random 난수 생성, seed 지정 가능 regex 정규 표현식 지원, 텍스트 검색 및 치환 Scanner 콘솔/파일 입력을 편리하게 받을 때 사용 StringTokenizer 문자열을 여러 구분자로 토큰화 (split과 차이) BigInteger 매우 큰 정수 연산 지원 BigDecimal 고정소수점 연산, 금융 계산 등 정밀한 소수점 연산에 사용 날짜와 시간 Java 8 이전: Date, Calendar 클래스 사용 (불변 객체 아님, 복잡함) Java 8 이후: java.time 패키지 도입 불변 객체, 명확한 API 제공 날짜, 시간, 기간, 포맷팅, 파싱 등 다양한 기능 지원 날짜/시간 계산의 기본\n시분초 → 초로 변환, 계산 후 다시 시분초로 변환 년월일 → 일로 변환, 계산 후 다시 년월일로 변환 마무리 이번 주에는 자바의 예외 처리와 java.lang, java.util 패키지의 주요 클래스를 집중적으로 학습했다.\n프로젝트를 진행할 때마다 시간에 쫓겨 예외 처리나 테스트 코드 작성에 소홀했던 경험이 많았는데,\n실무에서는 로깅과 예외 처리, 그리고 테스트 코드의 중요성을 다시 한 번 깨달았다.\n실제로 전 직장에서 개발팀에 로그를 요청해 업무에 활용한 경험이 있었고,\n이 과정에서 로그가 안정적이고 유지보수하기 쉬운 코드를 작성하는 데 큰 도움이 될 뿐만 아니라,\n서비스 운영 중 발생하는 문제를 신속하게 해결하는 데도 매우 유용하다는 점을 체감했다.\n이러한 경험을 바탕으로 앞으로는 기능 구현뿐만 아니라 예외 처리와 테스트 코드 작성에도 더욱 신경 써야겠다고 다짐했다.\n앞으로는 꼼꼼하게 예외 처리와 테스트 코드를 챙기는 습관을 들여\n더 신뢰받는 개발자가 되고자 한다. ","date":"2025-07-04T00:00:00Z","permalink":"http://localhost:1313/posts/week3-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 3주차"},{"content":" 이번 주 키워드 객체 지향 설계, 클래스, 생성자, 추상클래스, 인터페이스 객체 지향이란? 객체 지향(Object-Oriented Programming, OOP) 은 현실 세계를 컴퓨터 안에 구현하는 방식 즉, 우리가 보는 세상처럼 데이터와 그 데이터를 다루는 행위를 객체라는 단위로 묶어서 표현하는 것\n실제 세계 분석, 관찰 → 설계(클래스 작성) → 객체 생성 → 객체 사용\nOOP의 목적\n코드 재사용성을 높이고\n유지보수를 쉽게 하며\n변화에 유연하게 대응할 수 있도록 함\n객체지향의 4대 원칙 캡슐화(Encapsulation)\n데이터(변수)와 기능(메서드)을 하나로 묶고 외부에서 직접 접근하지 못하게 막음 → 내부 구현은 숨기고, 인터페이스만 노출 → 복잡도 감소, 유지보수 용이 상속(Inheritance)\n기존 클래스를 확장하여 새로운 클래스를 생성 가능 → 코드 중복을 줄이고 공통 로직을 한 곳에서 관리\n추상화(Abstraction)\n공통적인 성질만 뽑아서 일반화한 개념 → 불필요한 정보는 숨기고 중요한 정보만 표현 → 예: 동물 → 고양이/강아지 (공통 행동: 먹다, 자다)\n다형성(Polymorphism)\n하나의 참조변수로 여러 객체 다루기\n다형적 매개변수\n하나의 배열에 여러 객체 저장\n클래스 정의\n설계도 변수 + 메서드 사용자 정의 타입 클래스 간의 관계\n상속 관계 (is-a) 자식 클래스가 부모 클래스를 확장 → ex) Dog extends Animal\n* 자바는 단일 상속만 지원\n포함 관계 (has-a) 하나의 클래스가 다른 클래스를 필드로 가짐 → ex) Person has a Address\n변수의 종류\n선언된 위치에 따라\n클래스 영역: class variable, instance variable 메서드 영역: local variable 생성자 변수의 초기화\n초기화 순서는 cv → iv, 자동(기본값) → 간단(대입 =) → 복잡({} 블럭) 순\n조건\n이름이 클래스와 동일 반환타입 없음(void안씀) 다른 생성자 호출은 반드시 첫줄에서 다른 생성자 호출시 this() 사용 오버라이딩 vs 오버로딩 오버라이딩(Overriding) 상속받은 메서드를 재정의하는 것 → 선언부는 같고, 구현부만 다르게 → 접근제어자: 부모보다 좁으면 안됨 → 반환 타입, 매개변수 동일해야 함\n오버로딩(Overloading) 같은 이름의 메서드를 여러 개 정의하는 것 → 매개변수의 개수나 타입이 달라야 함\n→ 반환타입은 영향을 미치지 않음\nsuper 키워드 super\n부모 클래스의 멤버(필드, 메서드)를 참조할 때 사용\nsuper()\n부모 생성자를 호출할 때 사용\n생성자의 첫 줄에는 반드시 this() 또는 super() 중 하나가 있어야 하며,\n없으면 컴파일러가 super()를 자동 삽입함\n다형성과 형변환 부모 타입으로 자식 객체를 참조할 수 있음 → 확장성과 유연성 확보\n하지만 자식 타입으로 다시 형변환하려면 instanceof로 확인해야 함\nif (animal instanceof Dog) { Dog dog = (Dog) animal; dog.bark(); } 형변환을 통해 참조 변수(리모컨)를 바꿔 객체가 가진 메서드 범위를 조절\n추상 클래스 (abstract class) 미완성 설계도 → 객체 생성 불가\n공통 부분은 구현하고, 바뀌는 부분만 추상 메서드로 정의\n상속받은 클래스가 추상 메서드를 반드시 구현해야 함\n인터페이스 (interface) 모든 메서드는 public abstract, 모든 변수는 public static final\n→ 생략해도 컴파일러가 자동 추가\n→ interface의 메서드를 오버라이딩하면 public을 반드시 붙여야 함 다중 구현 가능\n서로 관계없는 클래스에도 공통 기능 강제 가능\n+) 추상클래스는 iv를 가질 수 있지만 인터페이스는 iv를 가질 수 없음\n+) JDK 1.8 이후\ndefault, static 메서드 추가 가능\n→ 기존 구현 클래스에 영향 주지 않기 위해 도입\n→ default 메서드는 오버라이딩 가능\ninterface Animal { void sound(); // 추상 메서드 default void sleep() { System.out.println(\u0026#34;Sleeping...\u0026#34;); } } 마무리 예전에 면접을 봤을 때 객체지향에 대한 질문을 받고 제대로 답변하지 못했던 적이 있었는데\n여러 번 반복을 하고 강사님께서 강조하신 부분을 외우려고 노력을 하고 나니\n이제 객체지향이 뭔지, 어떤 특징을 가지고 있는지 등에 대해 확실히 정리가 된 것 같다.\n욕심 부리지 않고 조금씩 이론적인 부분에 대해 정리하고 설명할 수 있는 능력을 길러야겠다! ","date":"2025-06-27T00:00:00Z","permalink":"http://localhost:1313/posts/week2-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 2주차"},{"content":" 이번 주 키워드 변수, 설계 변수란? 자바에서 변수는 타입 + 이름으로 구성\n이 변수를 통해 쓰기(= 연산자), 읽기(변수명) 등의 작업을 수행 가능\n변수를 사용하는 이유?\n→ 컴파일러가 코드를 분석하고 오류를 사전에 잡을 수 있도록 하기 위해서\n컴파일러는 다음과 같은 작업을 수행:\n문법 체크 최적화 번역 (.java → .class) 📌 즉, 코드가 완벽하지 않아도 컴파일러가 이를 어느 정도 보완해줌\n변수의 종류 자바의 변수는 크게 두 가지:\n기본형(primitive): 하나의 요소 참조형(reference): 여러 개의 요소(집합) 참조형은 0~n개의 요소를 담는 집합이며,\n이 집합을 만들기 위해서는 기준을 가지고 그룹화를 수행\n➡️ 이것이 바로 설계\n설계란? 관련 있는 것끼리 하나의 집합으로 묶고 집합들 간의 관계를 정의\n설계를 하면 좋은 점:\n복잡도가 낮아지고 관리가 쉬워지며 더 복잡한 프로그램을 구현할 수 있게 됨 연산 연산이란 데이터를 계산하는 것\n같은 타입끼리만 연산 가능 반드시 결과를 반환해야 함 연산자에서 중요한 3요소:\n우선순위 결합법칙 산술 변환 둘 중 큰 타입으로 자동 변환 int보다 작은 타입끼리 연산 시 → int로 변환 후 연산 연습문제 정리 long형 변수에 정수값 저장 시 L을 붙이지 않으면 기본적으로 int로 인식\n→ int 범위 초과 시 컴파일 에러 발생\n'+' 연산자는\n둘 다 숫자 → 덧셈 하나라도 String → 문자열 이어붙이기 char + char / char + 숫자 → int 반환 단, ++, -- 같은 증감 연산자는 형변환 없이 char로 반환\n자바는 C처럼 0 = false, 1 = true를 인정하지 않음\n→ boolean에는 반드시 true / false 를 사용해야 함\nchar는 요소형 → 반드시 문자를 지정해야 함\n→ '' (빈 문자 리터럴) 사용 불가\n자바에서의 var Java 10부터 도입된 문법으로, 로컬 변수의 타입을 컴파일러가 자동 추론\n(컴파일 타임에 정적으로 결정, 런타임에 동적으로 바뀌지 않음)\n적절한 상황에 사용하면 코드의 가독성과 간결성이 좋아짐\n1. 타입이 너무 길어서 코드가 지저분할 때 // before Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // after var map = new HashMap\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt;(); 2. 우측 표현식으로 타입이 분명히 드러날 때 var name = \u0026#34;Soyeon\u0026#34;; // String var count = 123; // int var list = List.of(1, 2); // List\u0026lt;Integer\u0026gt; 3. for-each 루프에서 반복 변수 for (var item : items) { System.out.println(item); } 📌 주의:\nvar는 명시적인 타입 지정이 아닌 추론이기 때문에, 복잡한 표현식에서는 오히려 가독성을 해칠 수 있음 클래스 필드, 메서드 매개변수, 리턴 타입에는 사용할 수 없음 (오직 로컬 변수에만 사용 가능) → 사람이 읽을 수 있을 만큼만 추론을 맡기고 그렇지 않으면 명시적으로 타입을 작성하자! 마무리 java 기초 부분은 어느 정도 안다고 생각했는데 연습문제를 풀어보니\n컴파일러가 있어서 아무 생각 없이 코드를 작성하던 부분이 많았다는 것을 느꼈다.\n예습 복습을 하면서 기초를 탄탄히 다져야겠다! ","date":"2025-06-23T00:00:00Z","permalink":"http://localhost:1313/posts/week1-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 1주차]"}]