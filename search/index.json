[{"content":"이번 주 키워드 예외 처리, java.lang 패키지, 유용한 자바 클래스\n프로그램 오류와 예외 프로그램 오류란? 프로그램 실행 중 오작동을 하거나 비정상적으로 종료되게 하는 원인 발생 시점에 따라 아래와 같이 구분됨\n컴파일 에러: 코드 작성 중 컴파일러가 잡아내는 문법 오류 런타임 에러: 실행 중 발생하는 오류 (예: 0으로 나누기, 배열 인덱스 초과) 논리적 에러: 실행은 되지만, 의도와 다르게 동작하는 오류 에러와 예외 에러(Error): 프로그램 코드로 수습할 수 없는 심각한 오류 (예: OutOfMemoryError) 예외(Exception): 코드로 수습 가능한 비교적 덜 심각한 오류 실행 중 발생하는 에러와 예외는 모두 Throwable의 하위 클래스\nThrowable ├─ Error // 시스템 오류, 복구 불가 └─ Exception // 예외 상황, 복구 가능 ├─ RuntimeException (개발자 실수) └─ 기타 Exception (사용자 실수 등) 예외 처리 예외 처리란? 프로그램 실행 중 발생할 수 있는 예기치 못한 예외에 대비한 코드를 작성하는 것 예외 발생으로 인한 프로그램의 갑작스런 종료를 막고 정상적인 실행 상태를 유지하기 위함\n예외 처리의 기본은 로깅 (에러가 발생했을 때 상태와 원인을 기록하여 추후 원인 분석 및 유지보수에 활용)\n예외 처리 방법 try-catch: 직접 예외를 처리 throws: 예외를 호출자에게 전달 예외 은폐: 예외를 일부러 무시(권장하지 않음) 예외 되던지기(rethrow): catch에서 예외를 다시 던짐 try-catch 기본 구조 try { // 예외가 발생할 수 있는 코드 } catch (ExceptionType e) { // 예외 처리 코드 } finally { // 항상 실행되는 코드 (리소스 반환 등) } 예시 public class Example { public static void main(String[] args) { int number = 100; int result = 0; for (int i = 0; i \u0026lt; 10; i++) { try { result = number / (int)(Math.random() * 10); System.out.println(result); } catch (ArithmeticException e) { System.out.println(\u0026#34;0\u0026#34;); } } } } multi-catch (Java 7+) try { // ... } catch (IOException | SQLException e) { e.printStackTrace(); } 조상-자손 관계 예외는 묶을 수 없음 멀티 catch 블록 내에서는 공통 조상 타입의 멤버만 사용 가능 예외 발생시키기 (throw) throw new Exception(\u0026#34;강제 예외 발생\u0026#34;); 예외의 종류 Checked Exception: 컴파일러가 예외 처리를 강제 (예: IOException) Unchecked Exception: RuntimeException 및 그 자손, 컴파일러가 체크하지 않음 메서드에서 예외 선언 (throws) public void readFile() throws IOException { // 파일 읽기 코드 } finally 블록 예외 발생 여부와 관계없이 항상 실행 주로 리소스 반환, 파일 닫기 등에 사용 try-with-resources (Java 7+) try (BufferedReader br = new BufferedReader(new FileReader(\u0026#34;file.txt\u0026#34;))) { // 파일 읽기 } catch(IOException e) { e.printStackTrace(); } AutoCloseable 구현 객체는 자동으로 close() 호출 예외 되던지기(rethrow) catch 블록에서 예외를 다시 던져 호출자에게 전달 사용자 정의 예외 Exception을 상속받아 직접 정의 가능 기존 예외로 충분하다면 가급적 표준 예외 사용 권장 예외 연결 (Chained Exception) 예외를 더 큰 단위로 묶어 처리 가능 catch 블록을 단순화할 수 있음 java.lang 패키지 주요 클래스 Object 클래스 모든 자바 클래스의 최상위 조상 주요 메서드: equals(Object obj): 객체 내용 비교 (오버라이딩 가능) hashCode(): 해시코드 반환, 컬렉션에서 사용 clone(): 객체 복제 (Cloneable 구현 필요) getClass(): 클래스 정보 반환 String 클래스 Immutable: 한 번 생성되면 변경 불가 문자열 리터럴은 상수 풀에서 관리되어 같은 문자열은 같은 객체 참조 주요 메서드/특징 trim(): 아스키 공백만 제거 strip(): 유니코드 공백도 제거 join(), StringJoiner: 구분자를 넣어 문자열 결합 getBytes(String charsetName): 인코딩 변환 format(), formatted(): 형식화된 문자열 생성 valueOf(): 기본형 → String 변환 parse자료형(): String → 기본형 변환 StringBuffer와 StringBuilder StringBuffer: 스레드 안전, 동기화 지원 StringBuilder: 동기화 미지원, 더 빠름 equals() 오버라이딩 X → 내용 비교시 String으로 변환 후 비교 Math 클래스 산술 연산 보조 메서드 제공 (addExact, subtractExact 등) 오버플로우 체크 가능 StrictMath: 플랫폼에 상관없이 일관된 결과 보장 래퍼(Wrapper) 클래스 기본형 값을 객체로 다룰 때 사용 (Integer, Double, Boolean 등) 오토박싱/언박싱 지원 -128~127 범위는 캐시로 재사용 java.util 주요 클래스 클래스 용도 Objects null 체크, 객체 비교 등 유틸리티 메서드 제공 Random 난수 생성, seed 지정 가능 regex 정규 표현식 지원, 텍스트 검색 및 치환 Scanner 콘솔/파일 입력을 편리하게 받을 때 사용 StringTokenizer 문자열을 여러 구분자로 토큰화 (split과 차이) BigInteger 매우 큰 정수 연산 지원 BigDecimal 고정소수점 연산, 금융 계산 등 정밀한 소수점 연산에 사용 날짜와 시간 Java 8 이전: Date, Calendar 클래스 사용 (불변 객체 아님, 복잡함) Java 8 이후: java.time 패키지 도입 불변 객체, 명확한 API 제공 날짜, 시간, 기간, 포맷팅, 파싱 등 다양한 기능 지원 날짜/시간 계산의 기본 시분초 → 초로 변환, 계산 후 다시 시분초로 변환 년월일 → 일로 변환, 계산 후 다시 년월일로 변환 마무리 이번 주에는 자바의 예외 처리와 java.lang, java.util 패키지의 주요 클래스를 집중적으로 학습했다.\n프로젝트를 진행할 때마다 시간에 쫓겨 예외 처리나 테스트 코드 작성에 소홀했던 경험이 많았는데, 실무에서는 로깅과 예외 처리, 그리고 테스트 코드의 중요성을 다시 한 번 깨달았다.\n실제로 전 직장에서 개발팀에 로그를 요청해 업무에 활용한 경험이 있었고, 이 과정에서 로그가 안정적이고 유지보수하기 쉬운 코드를 작성하는 데 큰 도움이 될 뿐만 아니라, 서비스 운영 중 발생하는 문제를 신속하게 해결하는 데도 매우 유용하다는 점을 체감했다. 이러한 경험을 바탕으로 앞으로는 기능 구현뿐만 아니라 예외 처리와 테스트 코드 작성에도 더욱 신경 써야겠다고 다짐했다.\n앞으로는 꼼꼼하게 예외 처리와 테스트 코드를 챙기는 습관을 들여 더 신뢰받는 개발자가 되고자 한다.\n","date":"2025-07-04T00:00:00Z","permalink":"http://localhost:1313/posts/week3-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 3주차"},{"content":" 이번 주 키워드 객체 지향 설계, 클래스, 생성자, 추상클래스, 인터페이스 객체 지향이란? 객체 지향(Object-Oriented Programming, OOP) 은 현실 세계를 컴퓨터 안에 구현하는 방식 즉, 우리가 보는 세상처럼 데이터와 그 데이터를 다루는 행위를 객체라는 단위로 묶어서 표현하는 것\n실제 세계 분석, 관찰 → 설계(클래스 작성) → 객체 생성 → 객체 사용\nOOP의 목적\n코드 재사용성을 높이고\n유지보수를 쉽게 하며\n변화에 유연하게 대응할 수 있도록 함\n객체지향의 4대 원칙 캡슐화(Encapsulation)\n데이터(변수)와 기능(메서드)을 하나로 묶고 외부에서 직접 접근하지 못하게 막음 → 내부 구현은 숨기고, 인터페이스만 노출 → 복잡도 감소, 유지보수 용이 상속(Inheritance)\n기존 클래스를 확장하여 새로운 클래스를 생성 가능 → 코드 중복을 줄이고 공통 로직을 한 곳에서 관리\n추상화(Abstraction)\n공통적인 성질만 뽑아서 일반화한 개념 → 불필요한 정보는 숨기고 중요한 정보만 표현 → 예: 동물 → 고양이/강아지 (공통 행동: 먹다, 자다)\n다형성(Polymorphism)\n하나의 참조변수로 여러 객체 다루기\n다형적 매개변수\n하나의 배열에 여러 객체 저장\n클래스 정의\n설계도 변수 + 메서드 사용자 정의 타입 클래스 간의 관계\n상속 관계 (is-a) 자식 클래스가 부모 클래스를 확장 → ex) Dog extends Animal\n* 자바는 단일 상속만 지원\n포함 관계 (has-a) 하나의 클래스가 다른 클래스를 필드로 가짐 → ex) Person has a Address\n변수의 종류\n선언된 위치에 따라\n클래스 영역: class variable, instance variable 메서드 영역: local variable 생성자 변수의 초기화\n초기화 순서는 cv → iv, 자동(기본값) → 간단(대입 =) → 복잡({} 블럭) 순\n조건\n이름이 클래스와 동일 반환타입 없음(void안씀) 다른 생성자 호출은 반드시 첫줄에서 다른 생성자 호출시 this() 사용 오버라이딩 vs 오버로딩 오버라이딩(Overriding) 상속받은 메서드를 재정의하는 것 → 선언부는 같고, 구현부만 다르게 → 접근제어자: 부모보다 좁으면 안됨 → 반환 타입, 매개변수 동일해야 함\n오버로딩(Overloading) 같은 이름의 메서드를 여러 개 정의하는 것 → 매개변수의 개수나 타입이 달라야 함\n→ 반환타입은 영향을 미치지 않음\nsuper 키워드 super\n부모 클래스의 멤버(필드, 메서드)를 참조할 때 사용\nsuper()\n부모 생성자를 호출할 때 사용\n생성자의 첫 줄에는 반드시 this() 또는 super() 중 하나가 있어야 하며,\n없으면 컴파일러가 super()를 자동 삽입함\n다형성과 형변환 부모 타입으로 자식 객체를 참조할 수 있음 → 확장성과 유연성 확보\n하지만 자식 타입으로 다시 형변환하려면 instanceof로 확인해야 함\nif (animal instanceof Dog) { Dog dog = (Dog) animal; dog.bark(); } 형변환을 통해 참조 변수(리모컨)를 바꿔 객체가 가진 메서드 범위를 조절\n추상 클래스 (abstract class) 미완성 설계도 → 객체 생성 불가\n공통 부분은 구현하고, 바뀌는 부분만 추상 메서드로 정의\n상속받은 클래스가 추상 메서드를 반드시 구현해야 함\n인터페이스 (interface) 모든 메서드는 public abstract, 모든 변수는 public static final\n→ 생략해도 컴파일러가 자동 추가\n→ interface의 메서드를 오버라이딩하면 public을 반드시 붙여야 함 다중 구현 가능\n서로 관계없는 클래스에도 공통 기능 강제 가능\n+) 추상클래스는 iv를 가질 수 있지만 인터페이스는 iv를 가질 수 없음\n+) JDK 1.8 이후\ndefault, static 메서드 추가 가능\n→ 기존 구현 클래스에 영향 주지 않기 위해 도입\n→ default 메서드는 오버라이딩 가능\ninterface Animal { void sound(); // 추상 메서드 default void sleep() { System.out.println(\u0026#34;Sleeping...\u0026#34;); } } 마무리 예전에 면접을 봤을 때 객체지향에 대한 질문을 받고 제대로 답변하지 못했던 적이 있었는데\n여러 번 반복을 하고 강사님께서 강조하신 부분을 외우려고 노력을 하고 나니\n이제 객체지향이 뭔지, 어떤 특징을 가지고 있는지 등에 대해 확실히 정리가 된 것 같다.\n욕심 부리지 않고 조금씩 이론적인 부분에 대해 정리하고 설명할 수 있는 능력을 길러야겠다! ","date":"2025-06-27T00:00:00Z","permalink":"http://localhost:1313/posts/week2-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 2주차"},{"content":" 이번 주 키워드 변수, 설계 변수란? 자바에서 변수는 타입 + 이름으로 구성\n이 변수를 통해 쓰기(= 연산자), 읽기(변수명) 등의 작업을 수행 가능\n변수를 사용하는 이유?\n→ 컴파일러가 코드를 분석하고 오류를 사전에 잡을 수 있도록 하기 위해서\n컴파일러는 다음과 같은 작업을 수행:\n문법 체크 최적화 번역 (.java → .class) 📌 즉, 코드가 완벽하지 않아도 컴파일러가 이를 어느 정도 보완해줌\n변수의 종류 자바의 변수는 크게 두 가지:\n기본형(primitive): 하나의 요소 참조형(reference): 여러 개의 요소(집합) 참조형은 0~n개의 요소를 담는 집합이며,\n이 집합을 만들기 위해서는 기준을 가지고 그룹화를 수행\n➡️ 이것이 바로 설계\n설계란? 관련 있는 것끼리 하나의 집합으로 묶고 집합들 간의 관계를 정의\n설계를 하면 좋은 점:\n복잡도가 낮아지고 관리가 쉬워지며 더 복잡한 프로그램을 구현할 수 있게 됨 연산 연산이란 데이터를 계산하는 것\n같은 타입끼리만 연산 가능 반드시 결과를 반환해야 함 연산자에서 중요한 3요소:\n우선순위 결합법칙 산술 변환 둘 중 큰 타입으로 자동 변환 int보다 작은 타입끼리 연산 시 → int로 변환 후 연산 연습문제 정리 long형 변수에 정수값 저장 시 L을 붙이지 않으면 기본적으로 int로 인식\n→ int 범위 초과 시 컴파일 에러 발생\n'+' 연산자는\n둘 다 숫자 → 덧셈 하나라도 String → 문자열 이어붙이기 char + char / char + 숫자 → int 반환 단, ++, -- 같은 증감 연산자는 형변환 없이 char로 반환\n자바는 C처럼 0 = false, 1 = true를 인정하지 않음\n→ boolean에는 반드시 true / false 를 사용해야 함\nchar는 요소형 → 반드시 문자를 지정해야 함\n→ '' (빈 문자 리터럴) 사용 불가\n자바에서의 var Java 10부터 도입된 문법으로, 로컬 변수의 타입을 컴파일러가 자동 추론\n(컴파일 타임에 정적으로 결정, 런타임에 동적으로 바뀌지 않음)\n적절한 상황에 사용하면 코드의 가독성과 간결성이 좋아짐\n1. 타입이 너무 길어서 코드가 지저분할 때 // before Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // after var map = new HashMap\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt;(); 2. 우측 표현식으로 타입이 분명히 드러날 때 var name = \u0026#34;Soyeon\u0026#34;; // String var count = 123; // int var list = List.of(1, 2); // List\u0026lt;Integer\u0026gt; 3. for-each 루프에서 반복 변수 for (var item : items) { System.out.println(item); } 📌 주의:\nvar는 명시적인 타입 지정이 아닌 추론이기 때문에, 복잡한 표현식에서는 오히려 가독성을 해칠 수 있음 클래스 필드, 메서드 매개변수, 리턴 타입에는 사용할 수 없음 (오직 로컬 변수에만 사용 가능) → 사람이 읽을 수 있을 만큼만 추론을 맡기고 그렇지 않으면 명시적으로 타입을 작성하자! 마무리 java 기초 부분은 어느 정도 안다고 생각했는데 연습문제를 풀어보니\n컴파일러가 있어서 아무 생각 없이 코드를 작성하던 부분이 많았다는 것을 느꼈다.\n예습 복습을 하면서 기초를 탄탄히 다져야겠다! ","date":"2025-06-23T00:00:00Z","permalink":"http://localhost:1313/posts/week1-retrospective/","title":"[커널아카데미] 백엔드 개발 부트캠프 13기 1주차]"}]